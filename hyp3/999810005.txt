thumb modern mmus typically divide the virtual address space ( the range of addresses used by the processor ) into pages , each having a size which is a power of 2 , usually a few kilobytes , but they may be much larger the bottom bits of the address ( the offset within a page ) are left unchanged most mmus use an in-memory table of items called a '' page table '' , containing one '' page table entry '' ( pte ) per page , to map virtual page numbers to physical page numbers in main memory an associative cache of ptes is called a translation lookaside buffer ( tlb ) and is used to avoid the necessity of accessing the main memory every time a virtual address is mapped the physical page number is combined with the page offset to give the complete physical address sometimes , a pte prohibits access to a virtual page , perhaps because no physical random access memory has been allocated to that virtual page the operating system ( os ) then handles the situation , perhaps by trying to find a spare frame of ram and set up a new pte to map it to the requested virtual address if no ram is free , it may be necessary to choose an existing page ( known as a '' victim '' ) , using some replacement algorithm , and save it to disk ( a process called '' paging '' ) after blocks of memory have been allocated and freed , the free memory may become fragmented ( discontinuous ) so that the largest contiguous block of free memory may be much smaller than the total amount with virtual memory , a contiguous range of virtual addresses can be mapped to several non-contiguous blocks of physical memory ; this non-contiguous allocation is one of the benefits of paging later microprocessors ( such as the motorola 68030 and the zilog z280 ) placed the mmu together with the cpu on the same integrated circuit , as did the intel 80286 and later x86 microprocessors while this article concentrates on modern mmus , commonly based on pages , early systems used a similar concept for base-limit addressing that further developed into segmentation most modern systems divide memory into pages that are in size , often with the capability to use so called huge pages of or in size ( often both variants are possible ) some systems , mainly older risc designs , trap into the os when a page translation is not found in the tlb ; s0 space : ( or system space ) which is global to all processes and stores operating system code and data , whether paged or not , including pagetables normally , this would be very wasteful when addresses are used at both ends of the possible range , but the page table for applications is itself stored in the kernel 's paged memory typically , the os will periodically unmap pages so that page-not-present faults can be used to let the os set an accessed bit arm architecture-based application processors implement an mmu defined by arm 's virtual memory system architecture arm uses a two-level page table if using and pages , or just a one-level page table for sections and sections ptes include read/write access permission based on privilege , cacheability information , an nx bit , and a non-secure bit they refer to physical memory rather than virtual memory , and are accessed by special-purpose instructions this reduces overhead for the os , which would otherwise need to propagate accessed and dirty bits from the page tables to a more physically oriented data structure it also stores the accessed and dirty bits outside the page table after a tlb miss , low-level firmware machine code ( here called palcode ) walks a three-level tree-structured page table a vpn2 has a global status bit and an os assigned id which participates in the virtual address tlb entry match , if the global status bit is set to zero a tlb modified exception is generated when a store instruction references a mapped address and the matching entry 's dirty status is not set mips32 and mips32r2 support 32 bits of virtual address space and up to 36 bits of physical address space mips64 supports up to 64 bits of virtual address space and up to 59 bits of physical address space virtual addresses from the cpu are translated into intermediate addresses by the segment map , which in turn are translated into physical addresses by the page map the 4-bit context register can switch between 16 sections of the segment map under supervisor control , which allows 16 contexts to be mapped concurrently first , the top four bits of the address are used to select one of 16 segment registers the result may be looked up via a tree-structured page table , with the bits of the address being split as follows : 10 bits for the branch of the tree , 10 bits for the leaves of the branch , and the 12 lowest bits being directly copied to the result in all levels of the page table , the page table entry includes a nx bit bit if the address field is non-zero , it is a disk address of the block , which has previously been rolled out , so the block is fetched from disk and the pbit is set to one and the physical memory address updated to point to the block in memory ( another pbit ) copy descriptors contain a 20-bit address field giving index of the master descriptor in the master descriptor array 