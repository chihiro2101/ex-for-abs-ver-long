most dynamic recompilers are used to convert machine code between architectures at runtime in other cases , a system may employ dynamic recompilation as part of an adaptive optimization strategy to execute a portable program representation such as java or full-speed debuggers also utilize dynamic recompilation to reduce the space overhead incurred in most deoptimization techniques , and other features such as dynamic thread migration suppose a program is being run in an emulator and needs to copy a null-terminated string this processor can only copy a byte at a time , and must do so by first reading it from the source string into a register , then writing it from that register into the destination string the emulator might be running on a processor which is similar , but extremely good at copying strings , and the emulator knows it can take advantage of this our theoretical movs instruction copies 16 bytes at a time , without having to load them into register c in between , but will stop if it copies a 0 byte ( which marks the end of a string ) and set the zero flag later versions of the mac 68k emulator used in classic mac os to run 680x0 code on the powerpc hardware the vx32 employs dynamic recompilation to create os-independent x86 architecture sandboxes for safe application plugins gem , a game boy emulator for msx uses an optimizing dynamic recompiler recompilers both ppu and spu on cell processor for x86-64 decaf-emu , a wii u emulator , uses dynamic recompilation ( jit ) from powerpc32 to x86_64 code hardware using libbinrec library ( library itself can run on any hardware architecture ) 