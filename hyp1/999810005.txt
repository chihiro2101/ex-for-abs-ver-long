thumb modern mmus typically divide the virtual address space ( the range of addresses used by the processor ) into pages , each having a size which is a power of 2 , usually a few kilobytes , but they may be much larger the bottom bits of the address ( the offset within a page ) are left unchanged the upper address bits are the virtual page numbers most mmus use an in-memory table of items called a '' page table '' , containing one '' page table entry '' ( pte ) per page , to map virtual page numbers to physical page numbers in main memory an associative cache of ptes is called a translation lookaside buffer ( tlb ) and is used to avoid the necessity of accessing the main memory every time a virtual address is mapped other mmus may have a private array of memory or registers that hold a set of page table entries the physical page number is combined with the page offset to give the complete physical address sometimes , a pte prohibits access to a virtual page , perhaps because no physical random access memory has been allocated to that virtual page the operating system ( os ) then handles the situation , perhaps by trying to find a spare frame of ram and set up a new pte to map it to the requested virtual address if no ram is free , it may be necessary to choose an existing page ( known as a '' victim '' ) , using some replacement algorithm , and save it to disk ( a process called '' paging '' ) after blocks of memory have been allocated and freed , the free memory may become fragmented ( discontinuous ) so that the largest contiguous block of free memory may be much smaller than the total amount some systems , mainly older risc designs , trap into the os when a page translation is not found in the tlb ; p1 space : ( or control space ) which is also per-process and is typically used for supervisor , executive , kernel , user stacks and other per-process control structures managed by the operating system normally , this would be very wasteful when addresses are used at both ends of the possible range , but the page table for applications is itself stored in the kernel 's paged memory typically , the os will periodically unmap pages so that page-not-present faults can be used to let the os set an accessed bit arm uses a two-level page table if using and pages , or just a one-level page table for sections and sections this reduces overhead for the os , which would otherwise need to propagate accessed and dirty bits from the page tables to a more physically oriented data structure in early 1983 , the system/370-xa architecture expanded the virtual address space to 31 bits , and in 2000 , the 64-bit z/architecture was introduced , with the address space expanded to 64 bits ; those continue to store the accessed and dirty bits outside the page table addresses are broken down as follows : 21 bits unused , 10 bits to index the root level of the tree , 10 bits to index the middle level of the tree , 10 bits to index the leaf level of the tree , and 13 bits that pass through to the physical address without modification each tlb entry maps a virtual page number ( vpn2 ) to either one of two page frame numbers ( pfn0 or pfn1 ) , depending on the least significant bit of the virtual address that is not part of the page mask a vpn2 has a global status bit and an os assigned id which participates in the virtual address tlb entry match , if the global status bit is set to zero a pfn stores the physical address without the page mask bits if a tlb exception occurs when processing a tlb exception , a double fault tlb exception , it is dispatched to its own exception handler mips32 and mips32r2 support 32 bits of virtual address space and up to 36 bits of physical address space the original sun 1 is a single-board computer built around the motorola 68000 microprocessor and introduced in 1982 it includes the original sun 1 memory management unit that provides address translation , memory protection , memory sharing and memory allocation for multiple processes running on the cpu all access of the cpu to private on-board ram , external multibus memory , on-board i/o and the multibus i/o runs through the mmu , where address translation and protection are done in a uniform fashion virtual addresses from the cpu are translated into intermediate addresses by the segment map , which in turn are translated into physical addresses by the page map the 4-bit context register can switch between 16 sections of the segment map under supervisor control , which allows 16 contexts to be mapped concurrently then 24 bits from the segment register replace those four bits , producing a 52-bit address the os may generate the new entry from a more-normal tree-like page table or from per-mapping data structures which are likely to be slower and more space-efficient the segment register acts as an index into a table , which provides an offset to be added to the virtual address the burroughs b5000 from 1961 was the first commercial system to support virtual memory ( after the atlas ) , even though it has no mmu it provides the two functions of an mmu - virtual memory addresses and memory protection - with a different architectural approach first , in the mapping of virtual memory addresses , instead of needing an mmu , the mcp systems are descriptor-based if the address field is non-zero , it is a disk address of the block , which has previously been rolled out , so the block is fetched from disk and the pbit is set to one and the physical memory address updated to point to the block in memory ( another pbit ) 