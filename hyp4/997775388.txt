most dynamic recompilers are used to convert machine code between architectures at runtime full-speed debuggers also utilize dynamic recompilation to reduce the space overhead incurred in most deoptimization techniques , and other features such as dynamic thread migration suppose a program is being run in an emulator and needs to copy a null-terminated string this processor can only copy a byte at a time , and must do so by first reading it from the source string into a register , then writing it from that register into the destination string the emulator might be running on a processor which is similar , but extremely good at copying strings , and the emulator knows it can take advantage of this it might recognize the string copy sequence of instructions and decide to rewrite them more efficiently just before execution , to speed up the emulation say there is an instruction on our new processor called movs , specifically designed to copy strings efficiently our theoretical movs instruction copies 16 bytes at a time , without having to load them into register c in between , but will stop if it copies a 0 byte ( which marks the end of a string ) and set the zero flag many java virtual machine feature dynamic recompilation later versions of the mac 68k emulator used in classic mac os to run 680x0 code on the powerpc hardware recompilers both ppu and spu on cell processor for x86-64 decaf-emu , a wii u emulator , uses dynamic recompilation ( jit ) from powerpc32 to x86_64 code hardware using libbinrec library ( library itself can run on any hardware architecture ) 