Conversational Monitor System

history . cms was originally developed as part of ibm 's cp/cms operating system . at the time , the acronym meant '' cambridge monitor system '' ( but also : '' console monitor system '' ) . cms first ran under cp-40 , a one-off research system using custom hardware at ibm 's cambridge scientific center . production use at csc began in january 1967 . the cms user interface drew heavily on experience with the influential first-generation time-sharing system ctss , some of whose developers worked on cp/cms . ( ctss was used as an early cp/cms development platform . ) later in 1967 , cp/cms became generally available on the ibm system/360 model 67 , where , although the new control program cp-67 was a substantial re-implementation of cp-40 , cms remained essentially the same . ibm provided cp/cms '' as is '' & ndash ; without any support , in source code form , as part of the ibm type-iii library . cp/cms was thus an open source system . despite this lack of support from ibm , cp/cms achieved great success as a time-sharing platform ; by 1972 , there were some 44 cp/cms systems in use , including commercial sites that resold access to cp/cms . in 1972 , ibm released its vm/370 operating system , a re-implementation of cp/cms for the system/370 , in an announcement that also added virtual memory hardware to the system/370 series . unlike cp/cms , vm/370 was supported by ibm . vm went through a series of versions , and is still in use today as z/vm . through all its distinct versions and releases , the cms platform remained still quite recognizable as a close descendant of the original cms version running under cp-40 . many key user interface decisions familiar to today 's users had already been made in 1965 , as part of the cp-40 effort . see cms under cp-40 for examples . both vm and cp/cms had checkered histories at ibm . vm was not one of ibm 's '' strategic '' operating systems , which were primarily the os and dos families , and it suffered from ibm political infighting over time-sharing versus batch processing goals . this conflict is why cp/cms was originally released as an unsupported system , and why vm often had limited development and support resources within ibm . an exceptionally strong user community , first established in the self-support days of cp/cms but remaining active after the launch of vm , made substantial contributions to the operating system , and mitigated the difficulties of running ibm 's '' other operating system '' . architecture . cms is an intrinsic part of the vm/cms architecture , established with cp/cms . each cms user has control over a private virtual machine & ndash ; a simulated copy of the underlying physical computer & ndash ; in which cms runs as a stand-alone operating system . this approach has remained consistent through the years , and is based on : full virtualization , used to create multiple independent virtual machines that each completely simulate the underlying hardware paravirtualization , used to provide a hypervisor interface that cms uses to access vm services ; this is implemented by the non-virtualized diag ( diagnose ) instruction more details on how cms interacts with the virtual machine environment can be found in the vm and cp/cms articles . cms was originally built as a stand-alone operating system , capable of running on a bare machine ( though of course nobody would choose to do so ) . however , cms can no longer run outside the vm environment , which provides the hypervisor interface needed for various critical functions . features . cms provides users an environment for running applications or batch jobs , managing data files , creating and debugging applications , doing cross-platform development , and communicating with other systems or users . cms is still in development and wide use today . basic environment . users log into vm , providing a userid and password , and then boot their own virtual machine . this can be done by issuing the command '' ipl cms '' ( '' ipl '' initial program load , traditional ibm jargon for booting a machine ) ; though this is normally done automatically for the user . personal customization is done by a standard shell script file named '' profile exec '' , which sets up user-specified environmental defaults , such as which disks and libraries are accessed . terminal support . cms started in the era of teletype-style paper terminals , and the later '' glass teletype '' dumb terminals . by the late 1970s , however , most vm users were connecting via full-screen terminals & ndash ; particularly the ibm 3270 , the ubiquitous transaction processing terminal on ibm mainframes . the 3270 played a strategic role in ibm 's product line , making its selection a natural choice for large data centers of the day . many other manufacturers eventually offered bisync terminals that emulated the 3270 protocol . 3270s had local buffer storage , some processing capabilities , and generally dealt with an entire screen of data at a time . they handled editing tasks locally , and then transmitted a set of fields ( or the entire page ) at once when the enter key or a function key ( pfk ) was pressed . the 3270 family incorporated '' smart '' control units , concentrators , and other network processing elements , communicating with the mainframe over dedicated circuits at relatively high speeds , via a bisync synchronous data transmission protocol . ( these mainframe-oriented communication technologies provided some of the capabilities taken for granted in modern communication networks , such as device addressing , routing , error correction , and support for a variety of configurations such as multipoint and multidrop topologies . ) the 3270 approach differed from lower-cost dumb terminals of the period , which were point-to-point and asynchronous . commercial time-sharing users , an important segment of early cp/cms and vm sites , relied on such devices because they could connect via 300- or 1200 bit/s modems over normal voice-grade telephone circuits . installing a dedicated circuit for a 3270 was often not practical , economical , or timely . the 3270 's block-oriented approach was more consistent with ibm 's batch- and punched card-oriented view of computing , and was particularly important for ibm mainframes of the day . unlike contemporary minicomputers , most ibm mainframes were not equipped for character-at-a-time interrupts . dumb terminal support relied on terminal control units such as the ibm 270x ( see ibm 3705 ) or memorex 1270 . these asynchronous terminal controllers assembled a line of characters , up to a fixed maximum length , until the return key was pressed . typing too many characters would result in an error , a familiar situation to users of the day . ( most data centers did not include this equipment , except as needed for dial-up access . the 3270 approach was preferred . ) block-oriented terminals like the 3270 made it practical to implement text editor on mainframes & ndash ; as opposed to line editor , the previous norm . this had been an important advantage of contemporary minicomputers and other character-oriented systems , and its availability via the 3270 was warmly welcomed . a gulf developed between the 3270 world , focused on page-oriented mainframe transaction processing ( especially via cics ) , and the asynch terminal world , focused on character-oriented minicomputers and dial-up timesharing . asynchronous terminal vendors gradually improved their products with a range of smart terminal features , usually accessed via escape sequences . however , these devices rarely competed for 3270 users ; ibm maintained its dominance over mainframe data center hardware purchase decisions . viewed in retrospect , there was a major philosophical divergence between block-oriented and character-oriented computing . asynchronous terminal controllers and 3270s both provided the mainframe with block-oriented interactions & ndash ; essentially , they made the terminal input look like a card reader . this approach , preferred by ibm , led to the development of entirely different user interface paradigms and programming strategies . character-oriented systems evolved differently . the difference is apparent when comparing the atomic transaction approach of dominant cics with the interactive , stream-oriented style of unix . vm/cms evolved somewhere between these extremes . cms has a command-driven , stateful , interactive environment , rather than adopting the cics approach of a stateless transaction-oriented interface . yet cms responds to page- or line-at-a-time interaction , instead of character interrupts . performance . cms earned a very good reputation for being efficient , and for having good human factors for ease of use , relative to the standards of the time ( and of course prior to widespread use of graphical user interface environments such as are commonly used today ) . it was not uncommon to have hundreds ( later : thousands ) of concurrent cms interactive users on the same vm mainframe , with sub-second response times for common , 'trivial ' functions . vm/cms consistently outperformed mvs and other ibm operating systems in terms of support for simultaneous interactive users . programming and major applications . many cms users programmed in such languages as cobol , fortran , pl/i , c/370 , apl , and the scripting language rexx . vm/cms was often used as a development platform for production systems that ran under ibm 's other operating systems , such as mvs . other cms users worked with commercial software packages such as focus , nomad , spss , and sas . at one time , cms was also a major environment for e-mail and office productivity ; an important product was ibm 's profs ( later renamed officevision ) . two commonly used cms tools are the editor xedit and the rexx programming language . both of these products have been ported to other platforms , and are now widely used outside the mainframe environment . references . see vm ( operating system ) for vm-related sources and source citations . notes . see also . cms file system