Dynamic recompilation

uses . most dynamic recompilers are used to convert machine code between architectures at runtime . this is a task often needed in the emulation of legacy gaming platforms . in other cases , a system may employ dynamic recompilation as part of an adaptive optimization strategy to execute a portable program representation such as java or . net common language runtime bytecodes . full-speed debuggers also utilize dynamic recompilation to reduce the space overhead incurred in most deoptimization techniques , and other features such as dynamic thread migration . tasks . the main tasks a dynamic recompiler has to perform are : reading in machine code from the source platform emitting machine code for the target platform a dynamic recompiler may also perform some auxiliary tasks : managing a cache of recompiled code updating of elapsed cycle counts on platforms with cycle count registers management of interrupt checking providing an interface to virtualized support hardware , for example a gpu optimizing higher level code structures to run efficiently on the target hardware ( see below ) . example . suppose a program is being run in an emulator and needs to copy a null-terminated string . the program is compiled originally for a very simple processor . this processor can only copy a byte at a time , and must do so by first reading it from the source string into a register , then writing it from that register into the destination string . the original program might look something like this : beginning : mov a , first string pointer ; put location of first character of source string ; in register a mov b , second string pointer ; put location of second character of destination string ; in register b loop : mov c , a ; copy byte at address in register a to register c mov b , c ; copy byte in register c to the address in register b inc a ; increment the address in register a to point to ; the next byte inc b ; increment the address in register b to point to ; the next byte cmp c , 0 ; compare the data we just copied to 0 ( string end marker ) jnz loop ; if it was n't 0 then we have more to copy , so go back ; and copy the next byte end : ; if we did n't loop then we must have finished , ; so carry on with something else . the emulator might be running on a processor which is similar , but extremely good at copying strings , and the emulator knows it can take advantage of this . it might recognize the string copy sequence of instructions and decide to rewrite them more efficiently just before execution , to speed up the emulation . say there is an instruction on our new processor called movs , specifically designed to copy strings efficiently . our theoretical movs instruction copies 16 bytes at a time , without having to load them into register c in between , but will stop if it copies a 0 byte ( which marks the end of a string ) and set the zero flag . it also knows that the addresses of the strings will be in registers a and b , so it increments a and b by 16 every time it executes , ready for the next copy . our new recompiled code might look something like this : beginning : mov a , first string pointer ; put location of first character of source string ; in register a mov b , second string pointer ; put location of first character of destination string ; in register b loop : movs b , a ; copy 16 bytes at address in register a to address ; in register b , then increment a and b by 16 jnz loop ; if the zero flag is n't set then we have n't reached ; the end of the string , so go back and copy some more . end : ; if we did n't loop then we must have finished , ; so carry on with something else . there is an immediate speed benefit simply because the processor does n't have to load so many instructions to do the same task , but also because the movs instruction is likely to be optimized by the processor designer to be more efficient than the sequence used in the first example . for example , it may make better use of parallel computing in the processor to increment a and b while it is still copying bytes . applications . general purpose . many java virtual machine feature dynamic recompilation . apple 's rosetta for mac os x on x86 , allows powerpc code to be run on the x86 architecture . later versions of the mac 68k emulator used in classic mac os to run 680x0 code on the powerpc hardware . psyco , a specializing compiler for python . the hp dynamo project , an example of a transparent binary dynamic optimizer . dynamorio , an open-source successor to dynamo that works with the arm , x86-64 and ia-64 ( itanium ) instruction sets . the vx32 employs dynamic recompilation to create os-independent x86 architecture sandboxes for safe application plugins . microsoft virtual pc for mac , used to run x86 code on powerpc . qemu , an open-source full system emulator . freekeyb , an international dos keyboard and console driver with many usability enhancements utilized self-modifying code and dynamic dead code elimination to minimize its in-memory image based on its user configuration ( selected features , languages , layouts ) and actual runtime environment ( os variant and version , loaded drivers , underlying hardware ) , automatically resolving dependencies , dynamically relocating and recombining code sections on byte-level granularity and optimizing opstrings based on semantic information provided in the source code , relocation information generated by special tools during assembly and profile information obtained at load time . ( nb . freekeyb is a unicode-based dynamically configurable successor of k3plus supporting most keyboard layouts , code pages , and country codes . k3plus was an extended keyboard driver for dos widely distributed in germany at its time , with adaptations to a handful of other european languages available . it did support a sub-set of the freekeyb features already , but was statically configured and did not support dynamic dead code elimination . ) ovpsim , a freely available full system emulator . virtualbox uses dynamic recompilation . valgrind , a programming tool for memory debugging , memory leak detection , and profiling , uses dynamic recompilation . gaming . mame uses dynamic recompilation in its cpu emulators for mips , superh , powerpc and even the voodoo graphics processing units . wii64 , a nintendo 64 emulator for the wii . wiisx , a sony playstation emulator for the nintendo wii . mupen64plus , a multi-platform nintendo 64 emulator . mupen64plus yabause , a multi-platform saturn emulator . the backwards compatibility functionality of the xbox 360 ( i.e . running games written for the original xbox ) is widely assumed to use dynamic recompilation . ppsspp , a sony playstation portable emulator . recompilers for both x86 and arm . psemu pro , a sony playstation emulator . ultrahle , the first nintendo 64 emulator to fully run commercial games . pcsx2 , a sony playstation 2 emulator , has a recompiler called '' microvu '' , the successor of '' supervu '' . dolphin , a nintendo gamecube and wii emulator , has a dynarec option . gcemu , a nintendo gamecube emulator . nulldc , a sega dreamcast emulator for x86 . gem , a game boy emulator for msx uses an optimizing dynamic recompiler . desmume , a nintendo ds emulator , has a dynarec option . soywiz 's psp , a sony playstation portable emulator , has a dynarec option . rpcs3 , a sony playstation 3 emulator . recompilers both ppu and spu on cell processor for x86-64 decaf-emu , a wii u emulator , uses dynamic recompilation ( jit ) from powerpc32 to x86_64 code hardware using libbinrec library ( library itself can run on any hardware architecture ) . see also . binary recompiler binary translation comparison of platform virtualization software just-in-time compilation instrumentation ( computer programming ) . references . external links . dynamic recompiler tutorial blog posts about writing a mips to ppc dynamic recompiler