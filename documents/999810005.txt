Memory management unit

overview . thumb modern mmus typically divide the virtual address space ( the range of addresses used by the processor ) into pages , each having a size which is a power of 2 , usually a few kilobytes , but they may be much larger . the bottom bits of the address ( the offset within a page ) are left unchanged . the upper address bits are the virtual page numbers . . page table entries . most mmus use an in-memory table of items called a '' page table '' , containing one '' page table entry '' ( pte ) per page , to map virtual page numbers to physical page numbers in main memory . an associative cache of ptes is called a translation lookaside buffer ( tlb ) and is used to avoid the necessity of accessing the main memory every time a virtual address is mapped . other mmus may have a private array of memory or registers that hold a set of page table entries . the physical page number is combined with the page offset to give the complete physical address . a pte may also include information about whether the page has been written to ( the '' dirty bit '' ) , when it was last used ( the '' accessed bit , '' for a least recently used ( lru ) page replacement algorithm ) , what kind of processes ( user mode or supervisor mode ) may read and write it , and whether it should be cached . sometimes , a pte prohibits access to a virtual page , perhaps because no physical random access memory has been allocated to that virtual page . in this case , the mmu signals a page fault to the cpu . the operating system ( os ) then handles the situation , perhaps by trying to find a spare frame of ram and set up a new pte to map it to the requested virtual address . if no ram is free , it may be necessary to choose an existing page ( known as a '' victim '' ) , using some replacement algorithm , and save it to disk ( a process called '' paging '' ) . with some mmus , there can also be a shortage of ptes , in which case the os will have to free one for the new mapping . the mmu may also generate illegal access error conditions or invalid page faults upon illegal or non-existing memory accesses , respectively , leading to segmentation fault or bus error conditions when handled by the operating system . benefits . image : vlsi vi475 hmmu chip from an apple macintosh ii - front.jpg thumb vlsi vi475 mmu '' apple hmmu '' from the macintosh ii used with the motorola 68020 in some cases , a page fault may indicate a software bug , which can be prevented by using memory protection as one of key benefits of an mmu : an operating system can use it to protect against errant programs by disallowing access to memory that a particular program should not have access to . typically , an operating system assigns each program its own virtual address space . an mmu also mitigates the problem of fragmentation of memory . after blocks of memory have been allocated and freed , the free memory may become fragmented ( discontinuous ) so that the largest contiguous block of free memory may be much smaller than the total amount . with virtual memory , a contiguous range of virtual addresses can be mapped to several non-contiguous blocks of physical memory ; this non-contiguous allocation is one of the benefits of paging . in some early microprocessor designs , memory management was performed by a separate integrated circuit such as the vlsi technology vi475 ( 1986 ) , the motorola 68851 ( 1984 ) used with the motorola 68020 cpu in the macintosh ii , or the z8010 and z8015 ( 1985 ) used with the zilog z8000 family of processors . later microprocessors ( such as the motorola 68030 and the zilog z280 ) placed the mmu together with the cpu on the same integrated circuit , as did the intel 80286 and later x86 microprocessors . while this article concentrates on modern mmus , commonly based on pages , early systems used a similar concept for base-limit addressing that further developed into segmentation . those are occasionally also present on modern architectures . the x86 architecture provided segmentation , rather than paging , in the 80286 , and provides both paging and segmentation in the 80386 and later processors ( although the use of segmentation is not available in 64-bit operation ) . examples . most modern systems divide memory into pages that are in size , often with the capability to use so called huge pages of or in size ( often both variants are possible ) . page translations are cached in a translation lookaside buffer ( tlb ) . some systems , mainly older risc designs , trap into the os when a page translation is not found in the tlb . most systems use a hardware-based tree walker . most systems allow the mmu to be disabled , but some disable the mmu when trapping into os code . vax . vax pages are 512 bytes , which is very small . an os may treat multiple pages as if they were a single larger page . for example , linux on vax groups eight pages together . thus , the system is viewed as having pages . the vax divides memory into four fixed-purpose regions , each in size . they are : ; p0 space : used for general-purpose per-process memory such as heaps . ; p1 space : ( or control space ) which is also per-process and is typically used for supervisor , executive , kernel , user stacks and other per-process control structures managed by the operating system . ; s0 space : ( or system space ) which is global to all processes and stores operating system code and data , whether paged or not , including pagetables . ; s1 space : which is unused and '' reserved to digital '' . page tables are big linear arrays . normally , this would be very wasteful when addresses are used at both ends of the possible range , but the page table for applications is itself stored in the kernel 's paged memory . thus , there is effectively a two-level tree , allowing applications to have sparse memory layout without wasting a lot of space on unused page table entries . the vax mmu is notable for lacking an accessed bit . oses which implement paging must find some way to emulate the accessed bit if they are to operate efficiently . typically , the os will periodically unmap pages so that page-not-present faults can be used to let the os set an accessed bit . arm . arm architecture-based application processors implement an mmu defined by arm 's virtual memory system architecture . the current architecture defines ptes for describing and pages , sections and super-sections ; legacy versions also defined a tiny page . arm uses a two-level page table if using and pages , or just a one-level page table for sections and sections . tlb updates are performed automatically by page table walking hardware . ptes include read/write access permission based on privilege , cacheability information , an nx bit , and a non-secure bit . . ibm system/360 model 67 , ibm system/370 , and successors . the ibm system/360 model 67 , which was introduced aug . 1965 , included an mmu called a dynamic address translation ( dat ) box . it has the unusual feature of storing accessed and dirty bits outside of the page table ( along with the four bit protection key for all s/360 processors ) . they refer to physical memory rather than virtual memory , and are accessed by special-purpose instructions . this reduces overhead for the os , which would otherwise need to propagate accessed and dirty bits from the page tables to a more physically oriented data structure . this makes os-level virtualization , later called paravirtualization , easier . starting in august , 1972 , the ibm system/370 has a similar mmu , although it initially supported only a 24-bit virtual address space rather than the 32-bit virtual address space of the system/360 model 67 . it also stores the accessed and dirty bits outside the page table . in early 1983 , the system/370-xa architecture expanded the virtual address space to 31 bits , and in 2000 , the 64-bit z/architecture was introduced , with the address space expanded to 64 bits ; those continue to store the accessed and dirty bits outside the page table . dec alpha . the dec alpha processor divides memory into pages . after a tlb miss , low-level firmware machine code ( here called palcode ) walks a three-level tree-structured page table . addresses are broken down as follows : 21 bits unused , 10 bits to index the root level of the tree , 10 bits to index the middle level of the tree , 10 bits to index the leaf level of the tree , and 13 bits that pass through to the physical address without modification . full read/write/execute permission bits are supported . mips . the mips architecture supports one to 64 entries in the tlb . the number of tlb entries is configurable at cpu configuration before synthesis . tlb entries are dual . each tlb entry maps a virtual page number ( vpn2 ) to either one of two page frame numbers ( pfn0 or pfn1 ) , depending on the least significant bit of the virtual address that is not part of the page mask . this bit and the page mask bits are not stored in the vpn2 . each tlb entry has its own page size , which can be any value from to in multiples of four . each pfn in a tlb entry has a caching attribute , a dirty and a valid status bit . a vpn2 has a global status bit and an os assigned id which participates in the virtual address tlb entry match , if the global status bit is set to zero . a pfn stores the physical address without the page mask bits . a tlb refill exception is generated when there are no entries in the tlb that match the mapped virtual address . a tlb invalid exception is generated when there is a match but the entry is marked invalid . a tlb modified exception is generated when a store instruction references a mapped address and the matching entry 's dirty status is not set . if a tlb exception occurs when processing a tlb exception , a double fault tlb exception , it is dispatched to its own exception handler . mips32 and mips32r2 support 32 bits of virtual address space and up to 36 bits of physical address space . mips64 supports up to 64 bits of virtual address space and up to 59 bits of physical address space . sun 1 . the original sun 1 is a single-board computer built around the motorola 68000 microprocessor and introduced in 1982 . it includes the original sun 1 memory management unit that provides address translation , memory protection , memory sharing and memory allocation for multiple processes running on the cpu . all access of the cpu to private on-board ram , external multibus memory , on-board i/o and the multibus i/o runs through the mmu , where address translation and protection are done in a uniform fashion . the mmu is implemented in hardware on the cpu board . the mmu consists of a context register , a segment map and a page map . virtual addresses from the cpu are translated into intermediate addresses by the segment map , which in turn are translated into physical addresses by the page map . the page size is and the segment size is which gives 16 pages per segment . up to 16 contexts can be mapped concurrently . the maximum logical address space for a context is or the maximum physical address that can be mapped simultaneously is also the context register is important in a multitasking operating system because it allows the cpu to switch between processes without reloading all the translation state information . the 4-bit context register can switch between 16 sections of the segment map under supervisor control , which allows 16 contexts to be mapped concurrently . each context has its own virtual address space . sharing of virtual address space and inter-context communications can be provided by writing the same values in to the segment or page maps of different contexts . additional contexts can be handled by treating the segment map as a context cache and replacing out-of-date contexts on a least-recently used basis . the context register makes no distinction between user and supervisor states . interrupts and traps do not switch contexts , which requires that all valid interrupt vectors always be mapped in page 0 of context , as well as the valid supervisor stack . sun 68000 board user 's manual , sun microsystems , inc , february 1983 , revision b . powerpc . in powerpc g1 , g2 , g3 , and g4 pages are normally after a tlb miss , the standard powerpc mmu begins two simultaneous lookups . one lookup attempts to match the address with one of four or eight data block address translation ( dbat ) registers , or four or eight instruction block address translation registers ( ibat ) , as appropriate . the bat registers can map linear chunks of memory as large as and are normally used by an os to map large portions of the address space for the os kernel 's own use . if the bat lookup succeeds , the other lookup is halted and ignored . the other lookup , not directly supported by all processors in this family , is via a so-called '' inverted page table , '' which acts as a hashed off-chip extension of the tlb . first , the top four bits of the address are used to select one of 16 segment registers . then 24 bits from the segment register replace those four bits , producing a 52-bit address . the use of segment registers allows multiple processes to share the same hash table . the 52-bit address is hashed , then used as an index into the off-chip table . there , a group of eight-page table entries is scanned for one that matches . if none match due to excessive hash collisions , the processor tries again with a slightly different hash function . if this , too , fails , the cpu traps into os ( with mmu disabled ) so that the problem may be resolved . the os needs to discard an entry from the hash table to make space for a new entry . the os may generate the new entry from a more-normal tree-like page table or from per-mapping data structures which are likely to be slower and more space-efficient . support for nx bit control is in the segment registers , leading to granularity . a major problem with this design is poor cache locality caused by the hash function . tree-based designs avoid this by placing the page table entries for adjacent pages in adjacent locations . an operating system running on the powerpc may minimize the size of the hash table to reduce this problem . it is also somewhat slow to remove the page table entries of a process . the os may avoid reusing segment values to delay facing this , or it may elect to suffer the waste of memory associated with per-process hash tables . g1 chips do not search for page table entries , but they do generate the hash , with the expectation that an os will search the standard hash table via software . the os can write to the tlb . g2 , g3 , and early g4 chips use hardware to search the hash table . the latest chips allow the os to choose either method . on chips that make this optional or do not support it at all , the os may choose to use a tree-based page table exclusively . ia-32 / x86 . the x86 architecture has evolved over a very long time while maintaining full software compatibility , even for os code . thus , the mmu is extremely complex , with many different possible operating modes . normal operation of the traditional 80386 cpu and its successors ( ia-32 ) is described here . the cpu primarily divides memory into pages . segment registers , fundamental to the older 8088 and 80286 mmu designs , are not used in modern oses , with one major exception : access to thread-specific data for applications or cpu-specific data for os kernels , which is done with explicit use of the fs and gs segment registers . all memory access involves a segment register , chosen according to the code being executed . the segment register acts as an index into a table , which provides an offset to be added to the virtual address . except when using fs or gs , the os ensures that the offset will be zero . after the offset is added , the address is masked to be no larger than 32 bits . the result may be looked up via a tree-structured page table , with the bits of the address being split as follows : 10 bits for the branch of the tree , 10 bits for the leaves of the branch , and the 12 lowest bits being directly copied to the result . some operating systems , such as openbsd with its w^x feature , and linux with the exec shield or pax patches , may also limit the length of the code segment , as specified by the cs register , to disallow execution of code in modifiable regions of the address space . minor revisions of the mmu introduced with the pentium have allowed very large pages by skipping the bottom level of the tree ( this leaves 10 bits for indexing the first level of page hierarchy with the remaining 10+12 bits being directly copied to the result ) . minor revisions of the mmu introduced with the pentium pro introduced the physical address extension ( pae ) feature , enabling 36-bit physical addresses with 2+9+9 bits for three-level page tables and 12 lowest bits being directly copied to the result . large pages are also available by skipping the bottom level of the tree ( resulting in 2+9 bits for two-level table hierarchy and the remaining 9+12 lowest bits copied directly ) . in addition , the page attribute table allowed specification of cacheability by looking up a few high bits in a small on-cpu table . nx bit support was originally only provided on a per-segment basis , making it very awkward to use . more recent x86 chips provide a per-page no-execute bit in the pae mode . the w^x , exec shield , and pax mechanisms described above emulate per-page non-execute support on machines x86 processors lacking the nx bit by setting the length of the code segment , with a performance loss and a reduction in the available address space . x86-64 . x86-64 is a 64-bit extension of x86 that almost entirely removes segmentation in favor of the flat memory model used by almost all operating systems for the 386 or newer processors . in long mode , all segment offsets are ignored , except for the fs and gs segments . when used with pages , the page table tree has four levels instead of three . the virtual addresses are divided as follows : 16 bits unused , nine bits each for four tree levels ( for a total of 36 bits ) , and the 12 lowest bits directly copied to the result . with pages , there are only three levels of page table , for a total of 27 bits used in paging and 21 bits of offset . some newer cpus also support a page with two levels of paging and of offset . cpuid can be used to determine if pages are supported . in all three cases , the bits are required to be equal to the 48th bit , or in other words , the low are sign extended to the higher bits . this is done to allow a future expansion of the addressable range , without compromising backwards compatibility . in all levels of the page table , the page table entry includes a nx bit bit . unisys mcp systems ( burroughs b5000 ) . the burroughs b5000 from 1961 was the first commercial system to support virtual memory ( after the atlas ) , even though it has no mmu it provides the two functions of an mmu - virtual memory addresses and memory protection - with a different architectural approach . first , in the mapping of virtual memory addresses , instead of needing an mmu , the mcp systems are descriptor-based . each allocated memory block is given a master descriptor with the properties of the block ( i.e . , the size , address , and whether present in memory ) . when a request is made to access the block for reading or writing , the hardware checks its presence via the presence bit ( pbit ) in the descriptor . a pbit of 1 indicates the presence of the block . in this case , the block can be accessed via the physical address in the descriptor . if the pbit is zero , an interrupt is generated for the mcp ( operating system ) to make the block present . if the address field is zero , this is the first access to this block , and it is allocated ( an init pbit ) . if the address field is non-zero , it is a disk address of the block , which has previously been rolled out , so the block is fetched from disk and the pbit is set to one and the physical memory address updated to point to the block in memory ( another pbit ) . this makes descriptors equivalent to a page-table entry in an mmu system . system performance can be monitored through the number of pbits . init pbits indicate initial allocations , but a high level of other pbits indicate that the system may be thrashing . all memory allocation is therefore completely automatic ( one of the features of modern systems ) and there is no way to allocate blocks other than this mechanism . there are no such calls as malloc or dealloc , since memory blocks are also automatically discarded . the scheme is also lazy , since a block will not be allocated until it is actually referenced . when memory is nearly full , the mcp examines the working set , trying compaction ( since the system is segmented , not paged ) , deallocating read-only segments ( such as code-segments which can be restored from their original copy ) and , as a last resort , rolling dirty data segments out to disk . another way the b5000 provides a function of a mmu is in protection . since all accesses are via the descriptor , the hardware can check that all accesses are within bounds and , in the case of a write , that the process has write permission . the mcp system is inherently secure and thus has no need of an mmu to provide this level of memory protection . descriptors are read only to user processes and may only be updated by the system ( hardware or mcp ) . ( words whose tag is an odd number are read-only ; descriptors have a tag of 5 and code words have a tag of 3 . ) blocks can be shared between processes via copy descriptors in the process stack . thus , some processes may have write permission , whereas others do not . a code segment is read only , thus reentrant and shared between processes . copy descriptors contain a 20-bit address field giving index of the master descriptor in the master descriptor array . this also implements a very efficient and secure ipc mechanism . blocks can easily be relocated , since only the master descriptor needs update when a block 's status changes . the only other aspect is performance do mmu-based or non-mmu-based systems provide better performance ? mcp systems may be implemented on top of standard hardware that does have an mmu ( for example , a standard pc ) . even if the system implementation uses the mmu in some way , this will not be at all visible at the mcp level . see also . memory controller memory management memory segmentation . references .