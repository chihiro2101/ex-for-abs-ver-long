Primality test

simple methods . the simplest primality test is trial division : given an input number , n , check whether it is evenly divisible by any prime number between 2 and ( i.e . that the division leaves no remainder ) . if so , then n is composite . otherwise , it is prime . riesel ( 1994 ) pp.2-3 for example , consider the number 100 , which is evenly divisible by these numbers : :2 , 4 , 5 , 10 , 20 , 25 , 50 note that the largest factor , 50 , is half of 100 . this holds true for all n : all divisors are less than or equal to n/2 . actually , when we test all possible divisors up to n/2 , we will discover some factors twice . to observe this , rewrite the list of divisors as a list of products , each equal to 100 : :2 × 50 , & nbsp ; & nbsp ; 4 × 25 , & nbsp ; & nbsp ; 5 × 20 , & nbsp ; & nbsp ; 10 × 10 , & nbsp ; & nbsp ; 20 × 5 , & nbsp ; & nbsp ; 25 × 4 , & nbsp ; & nbsp ; 50 × 2 notice that products past 10 x 10 merely repeat numbers which appeared in earlier products . for example , 5 x 20 and 20 x 5 consist of the same numbers . this holds true for all n : all unique divisors of n are numbers less than or equal to , so we need not search past that . ( in this example , 10 . ) all even numbers greater than 2 can also be eliminated since , if an even number can divide n , so can 2 . let 's use trial division to test the primality of 17 . we need only test for divisors up to , i.e . integers less than or equal to \scriptstyle \sqrt . other tests . leonard adleman and ming-deh huang presented an errorless ( but expected polynomial-time ) variant of the elliptic curve primality test . unlike the other probabilistic tests , this algorithm produces a primality certificate , and thus can be used to prove that a number is prime . the algorithm is prohibitively slow in practice . if quantum computers were available , primality could be tested big o notation than by using classical computers . a combination of shor 's algorithm , an integer factorization method , with the pocklington primality test could solve the problem in o ( ( \log n ) ^3 ( \log\log n ) ^2 \log\log\log n ) . . fast deterministic tests . near the beginning of the 20th century , it was shown that a corollary of fermat 's little theorem could be used to test for primality . this resulted in the pocklington primality test . however , as this test requires a partial factorization of n & nbsp ; − & nbsp ; 1 the running time was still quite slow in the worst case . the first deterministic primality test significantly faster than the naive methods was the cyclotomy test ; its runtime can be proven to be o ( ( log & nbsp ; n ) c & nbsp ; log & nbsp ; log & nbsp ; log & nbsp ; n ) , where n is the number to test for primality and c is a constant independent of n . many further improvements were made , but none could be proven to have polynomial running time . ( note that running time is measured in terms of the size of the input , which in this case is ~ log & nbsp ; n , that being the number of bits needed to represent the number n . ) the elliptic curve primality test can be proven to run in o ( ( log & nbsp ; n ) 6 ) , if some conjectures on analytic number theory are true . similarly , under the generalized riemann hypothesis , the deterministic miller 's test , which forms the basis of the probabilistic miller–rabin test , can be proved to run in õ ( ( log & nbsp ; n ) 4 ) . in practice , this algorithm is slower than the other two for sizes of numbers that can be dealt with at all . because the implementation of these two methods is rather difficult and creates a risk of programming errors , slower but simpler tests are often preferred . in 2002 , the first provably unconditional deterministic polynomial time test for primality was invented by manindra agrawal , neeraj kayal , and nitin saxena . the aks primality test runs in õ ( ( log & nbsp ; n ) 12 ) ( improved to õ ( ( log & nbsp ; n ) 7.5 ) in the published revision of their paper ) , which can be further reduced to õ ( ( log & nbsp ; n ) 6 ) if the sophie germain prime is true . subsequently , lenstra and pomerance presented a version of the test which runs in time õ ( ( log & nbsp ; n ) 6 ) unconditionally . agrawal , kayal and saxena suggest a variant of their algorithm which would run in õ ( ( log & nbsp ; n ) 3 ) if agrawal 's conjecture is true ; however , a heuristic argument by hendrik lenstra and carl pomerance suggests that it is probably false . a modified version of the agrawal 's conjecture , the agrawal–popovych conjecture , may still be true . complexity . in computational complexity theory , the formal language corresponding to the prime numbers is denoted as primes . it is easy to show that primes is in co-np : its complement composites is in np because one can decide compositeness by nondeterministically guessing a factor . in 1975 , vaughan pratt showed that there existed a certificate for primality that was checkable in polynomial time , and thus that primes was in np , and therefore in np & nbsp ; ∩ & nbsp ; conp . see primality certificate for details . the subsequent discovery of the solovay–strassen and miller–rabin algorithms put primes in corp . in 1992 , the adleman–huang algorithm reduced the complexity to zpp rp & nbsp ; ∩ & nbsp ; corp , which superseded pratt 's result . the adleman–pomerance–rumely primality test from 1983 put primes in qp ( quasi-polynomial time ) , which is not known to be comparable with the classes mentioned above . because of its tractability in practice , polynomial-time algorithms assuming the riemann hypothesis , and other similar evidence , it was long suspected but not proven that primality could be solved in polynomial time . the existence of the aks primality test finally settled this long-standing question and placed primes in p . however , primes is not known to be p-complete , and it is not known whether it lies in classes lying inside p such as nc or l . it is known that primes is not in ac0 . e . allender , m . saks , and i.e . shparlinski , a lower bound for primality , j . comp . syst . sci . 62 ( 2001 ) , pp . 356–366 . . number-theoretic methods . certain number-theoretic methods exist for testing whether a number is prime , such as the lucas test and proth 's test . these tests typically require factorization of n & nbsp ; + & nbsp ; 1 , n − 1 , or a similar quantity , which means that they are not useful for general-purpose primality testing , but they are often quite powerful when the tested number n is known to have a special form . the lucas test relies on the fact that the multiplicative order of a number a modulo n is n − 1 for a prime n when a is a primitive root modulo n . if we can show a is primitive for n , we can show n is prime .