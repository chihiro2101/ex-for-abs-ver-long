Tuple relational calculus

definition of the calculus . relational database . since the calculus is a query language for relational databases we first have to define a relational database . the basic relational building block is the domain ( somewhat similar , but not equal to , a data type ) . a tuple is a finite sequence of attributes , which are ordered pairs of domains and values . a relation is a set of ( compatible ) tuples . although these relational concepts are mathematically defined , those definitions map loosely to traditional database concepts . a table is an accepted visual representation of a relation ; a tuple is similar to the concept of a row . we first assume the existence of a set c of column names , examples of which are '' name '' , '' author '' , '' address '' , etcetera . we define headers as finite subsets of c . a relational database schema is defined as a tuple s ( d , r , h ) where d is the domain of atomic values ( see relational model for more on the notions of domain and atomic value ) , r is a finite set of relation names , and : h : r → 2 c a function that associates a header with each relation name in r . ( note that this is a simplification from the full relational model where there is more than one domain and a header is not just a set of column names but also maps these column names to a domain . ) given a domain d we define a tuple over d as a partial function that maps some column names to an atomic value in d . an example would be ( name : '' harry '' , age : 25 ) . : t : c ⇸ d the set of all tuples over d is denoted as t d . the subset of c for which a tuple t is defined is called the domain of t ( not to be confused with the domain in the schema ) and denoted as dom ( t ) . finally we define a relational database given a schema s ( d , r , h ) as a function : db : r → 2 t d that maps the relation names in r to finite subsets of t d , such that for every relation name r in r and tuple t in db ( r ) it holds that : dom ( t ) h ( r ) . the latter requirement simply says that all the tuples in a relation should contain the same column names , namely those defined for it in the schema . atoms . for the construction of the formulas we will assume an infinite set v of tuple variables . the formulas are defined given a database schema s ( d , r , h ) and a partial function type : v ⇸ 2 c , called at type assignment , that assigns headers to some tuple variables . we then define the set of atomic formulas as , type with the following rules : if v and w in v , a in type ( v ) and b in type ( w ) then the formula v.a w.b is in as , type , if v in v , a in type ( v ) and k denotes a value in d then the formula v.a k is in as , type , and if v in v , r in r and type ( v ) h ( r ) then the formula r ( v ) is in as , type . examples of atoms are : ( t.age s.age ) — t has an age attribute and s has an age attribute with the same value ( t.name '' codd '' ) — tuple t has a name attribute and its value is '' codd '' book ( t ) — tuple t is present in relation book . the formal semantics of such atoms is defined given a database db over s and a tuple variable binding val : v → t d that maps tuple variables to tuples over the domain in s : v.a w.b is true if and only if val ( v ) ( a ) val ( w ) ( b ) v.a k is true if and only if val ( v ) ( a ) k r ( v ) is true if and only if val ( v ) is in db ( r ) . formulas . the atoms can be combined into formulas , as is usual in first-order logic , with the logical operators ∧ ( and ) , ∨ ( or ) and ¬ ( not ) , and we can use the existential quantifier ( ∃ ) and the universal quantifier ( ∀ ) to bind the variables . we define the set of formulas fs , type inductively with the following rules : every atom in as , type is also in fs , type if f 1 and f 2 are in fs , type then the formula f 1 ∧ f 2 is also in fs , type if f 1 and f 2 are in fs , type then the formula f 1 ∨ f 2 is also in fs , type if f is in fs , type then the formula ¬ f is also in fs , type if v in v , h a header and f a formula in f [ s , type v- > h ] then the formula ∃ v : h ( f ) is also in fs , type , where type v- > h denotes the function that is equal to type except that it maps v to h , if v in v , h a header and f a formula in f [ s , type v- > h ] then the formula ∀ v : h ( f ) is also in fs , type examples of formulas : t.name '' c . j . date '' ∨ t.name '' h . darwen '' book ( t ) ∨ magazine ( t ) ∀ t : then the corresponding safe formula for v.b is : : v.b 1 ∨ v.b 2 ∨ ∃ w ( r ( w ) ∧ ( v.b w.a ∨ v.b w.b ) ) this formula , then , can be used to rewrite any unsafe query expression to an equivalent safe query expression by adding such a formula for every variable v and column name a in its type where it is used in the expression . effectively this means that we let all variables range over the active domain , which , as was already explained , does not change the semantics if the expressed query is domain independent . systems . des – an educational tool for working with tuple relational calculus and other formal languages winrdbi – an educational tool for working with tuple relational calculus and other formal languages