State diagram

overview . state diagrams are used to give an abstract description of the behavior of a system . this behavior is analyzed and represented by a series of events that can occur in one or more possible states . hereby '' each diagram usually represents objects of a single class and track the different states of its objects through the system '' . state diagrams can be used to graphically represent finite-state machines ( also called finite automata ) . this was introduced by claude shannon and warren weaver in their 1949 book a mathematical theory of communication . another source is taylor booth in his 1967 book sequential machines and automata theory . another possible representation is the state-transition table . directed graph . image : directed.svg 125px thumb a directed graph a classic form of state diagram for a finite automaton ( fa ) is a directed graph with the following elements ( q , σ , z , δ , q 0 , f ) : taylor booth ( 1967 ) sequential machines and automata theory , john wiley and sons , new york . john hopcroft and jeffrey ullman ( 1979 ) introduction to automata theory , languages , and computation , addison-wesley publishing company , reading mass , vertices q : a finite set of states , normally represented by circles and labeled with unique designator symbols or words written inside them input symbols σ : a finite collection of input symbols or designators output symbols z : a finite collection of output symbols or designators the output function ω represents the mapping of ordered pairs of input symbols and states onto output symbols , denoted mathematically as ω : σ × q→ z . edges δ : represent transitions from one state to another as caused by the input ( identified by their symbols drawn on the edges ) . an edge is usually drawn as an arrow directed from the present state to the next state . this mapping describes the state transition that is to occur on input of a particular symbol . this is written mathematically as δ : q × σ → q , so δ ( the transition function ) in the definition of the fa is given by both the pair of vertices connected by an edge and the symbol on an edge in a diagram representing this fa . item δ ( q , a ) p in the definition of the fa means that from the state named q under input symbol a , the transition to the state p occurs in this machine . in the diagram representing this fa , this is represented by an edge labeled by a pointing from the vertex labeled by q to the vertex labeled by p . start state q 0 : ( not shown in the examples below ) . the start state q 0 ∈ q is usually represented by an arrow with no origin pointing to the state . in older texts , edward j . mcclusky , introduction to the theory of switching circuits , mcgraw-hill , 1965 the start state is not shown and must be inferred from the text . accepting state ( s ) f : if used , for example for accepting automata , f ∈ q is the accept state . it is usually drawn as a double circle . sometimes the accept state ( s ) function as '' final '' ( halt , trapped ) states . for a deterministic finite automaton ( dfa ) , nondeterministic finite automaton ( nfa ) , generalized nondeterministic finite automaton ( gnfa ) , or moore machine , the input is denoted on each edge . for a mealy machine , input and output are signified on each edge , separated with a slash '' / '' : '' 1/0 '' denotes the state change upon encountering the symbol '' 1 '' causing the symbol '' 0 '' to be output . for a moore machine the state 's output is usually written inside the state 's circle , also separated from the state 's designator with a slash '' / '' . there are also variants that combine these two notations . for example , if a state has a number of outputs ( e.g . '' a motor counter-clockwise 1 , b caution light inactive 0 '' ) the diagram should reflect this : e.g . '' q5/1,0 '' designates state q5 with outputs a 1 , b 0 . this designator will be written inside the state 's circle . example : dfa , nfa , gnfa , or moore machine . s 1 and s 2 are states and s 1 is an accepting state or a final state . each edge is labeled with the input . this example shows an acceptor for binary numbers that contain an even number of zeros . :200px . example : mealy machine . s 0 , s 1 , and s 2 are states . each edge is labeled with '' j / k '' where j is the input and k is the output . : image : mealymachine jaredwf.png . harel statechart . harel statecharts , david harel , statecharts : a visual formalism for complex systems . science of computer programming , 8 ( 3 ) :231–274 , june 1987 . invented by computer scientist david harel , are gaining widespread usage since a variant has become part of the unified modeling language ( uml ) . the diagram type allows the modeling of superstates , orthogonal regions , and activities as part of a state . classic state diagrams require the creation of distinct nodes for every valid combination of parameters that define the state . this can lead to a very large number of nodes and transitions between nodes for all but the simplest of systems ( state and transition explosion ) . this complexity reduces the readability of the state diagram . with harel statecharts it is possible to model multiple cross-functional state diagrams within the statechart . each of these cross-functional state machines can transition internally without affecting the other state machines in the statechart . the current state of each cross-functional state machine in the statechart defines the state of the system . the harel statechart is equivalent to a state diagram but it improves the readability of the resulting diagram . alternative semantics . there are other sets of semantics available to represent state diagrams . for example , there are tools for modeling and designing logic for embedded controllers . tiwari , a . ( 2002 ) . formal semantics and analysis methods for simulink stateflow . these diagrams , like harel 's original state machines , harel , d . ( 1987 ) . a visual formalism for complex systems . science of computer programming , 231–274 . support hierarchically nested states , orthogonal regions , state actions , and transition actions . alur , r . , kanade , a . , ramesh , s . , & shashidhar , k . c . ( 2008 ) . symbolic analysis for improving simulation coverage of simulink/stateflow models . international conference on embedded software ( pp . 89–98 ) . atlanta , ga : acm . . state diagrams versus flowcharts . newcomers to the state machine formalism often confuse state diagrams with flowcharts . the figure below shows a comparison of a state diagram with a flowchart . a state machine ( panel ( a ) ) performs actions in response to explicit events . in contrast , the flowchart ( panel ( b ) ) does not need explicit events but rather transitions from node to node in its graph automatically upon completion of activities . : image : statechart vs flowchart.png nodes of flowcharts are edges in the induced graph of states . the reason is that each node in a flowchart represents a program command . a program command is an action to be executed . so it is not a state , but when applied to the program 's state , it results in a transition to another state . in more detail , the source code listing represents a program graph . executing the program graph ( parsing and interpreting ) results in a state graph . so each program graph induces a state graph . conversion of the program graph to its associated state graph is called '' unfolding '' of the program graph . the program graph is a sequence of commands . if no variables exist , then the state consists only of the program counter , which keeps track of where in the program we are during execution ( what is the next command to be applied ) . in this case before executing a command the program counter is at some position ( state before the command is executed ) . executing the command moves the program counter to the next command . since the program counter is the whole state , it follows that executing the command changed the state . so the command itself corresponds to a transition between the two states . now consider the full case , when variables exist and are affected by the program commands being executed . then between different program counter locations , not only does the program counter change , but variables might also change values , due to the commands executed . consequently , even if we revisit some program command ( e.g . in a loop ) , this does n't imply the program is in the same state . in the previous case , the program would be in the same state , because the whole state is just the program counter , so if the program counterpoints to the same position ( next command ) it suffices to specify that we are in the same state . however , if the state includes variables , then if those change value , we can be at the same program location with different variable values , meaning in a different state in the program 's state space . the term '' unfolding '' originates from this multiplication of locations when producing the state graph from the program graph . a representative example is a do loop incrementing some counter until it overflows and becomes 0 again . although the do loop executes the same increment command iteratively , so the program graph executes a cycle , in its state space is not a cycle , but a line . this results from the state being the program location ( here cycling ) combined with the counter value , which is strictly increasing ( until the overflow ) , so different states are visited in sequence , until the overflow . after the overflow the counter becomes 0 again , so the initial state is revisited in the state space , closing a cycle in the state space ( assuming the counter was initialized to 0 ) . the figure above attempts to show that reversal of roles by aligning the arcs of the state diagrams with the processing stages of the flowchart . you can compare a flowchart to an assembly line in manufacturing because the flowchart describes the progression of some task from beginning to end ( e.g . , transforming source code input into object code output by a compiler ) . a state machine generally has no notion of such a progression . the door state machine shown at the top of this article , for example , is not in a more advanced stage when it is in the '' closed '' state , compared to being in the '' opened '' state ; it simply reacts differently to the open/close events . a state in a state machine is an efficient way of specifying a particular behavior , rather than a stage of processing . other extensions . an interesting extension is to allow arcs to flow from any number of states to any number of states . this only makes sense if the system is allowed to be in multiple states at once , which implies that an individual state only describes a condition or other partial aspect of the overall , global state . the resulting formalism is known as a petri net . another extension allows the integration of flowcharts within harel statecharts . this extension supports the development of software that is both event driven and workflow driven .