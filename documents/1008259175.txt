Protected mode

history . the intel 8086 , the predecessor to the 286 , was originally designed with a 20-bit address bus for its memory . this allowed the processor to access 2 20 bytes of memory , equivalent to 1 megabyte . at the time , 1 megabyte was considered a relatively large amount of memory , so the designers of the ibm personal computer reserved the first 640 kilobytes for use by applications and the operating system and upper memory area for the bios ( basic input/output system ) and memory for peripheral . as the cost of memory decreased and memory use increased , the 1 mb limitation became a significant problem . intel intended to solve this limitation along with others with the release of the 286 . . the 286 . the initial protected mode , released with the 286 , was not widely used ; for example , it was used by microsoft xenix ( around 1984 ) , coherent and minix . several shortcomings such as the inability to access the bios or dos calls due to inability to switch back to real mode without resetting the processor prevented widespread usage . acceptance was additionally hampered by the fact that the 286 only allowed memory access in 16 bit segments via each of four segment registers , meaning only 4 2 16 bytes , equivalent to 256 kilobytes , could be accessed at a time . because changing a segment register in protected mode caused a 6-byte segment descriptor to be loaded into the cpu from memory , the segment register load instruction took many tens of processor cycles , making it much slower than on the 8086 ; therefore , the strategy of computing segment addresses on-the-fly in order to access data structures larger than 128 kilobytes ( the combined size of the two data segments ) became impractical , even for those few programmers who had mastered it on the 8086/8088 . the 286 maintained backwards compatibility with its precursor the 8086 by initially entering real mode on power up . real mode functioned virtually identically to the 8086 , allowing the vast majority of existing 8086 software to run unmodified on the newer 286 . real mode also served as a more basic mode in which protected mode could be set up , solving a sort of chicken-and-egg problem . to access the extended functionality of the 286 , the operating system would set up some tables in memory that controlled memory access in protected mode , set the addresses of those tables into some special registers of the processor , and then set the processor into protected mode . this enabled 24 bit addressing which allowed the processor to access 2 24 bytes of memory , equivalent to 16 megabytes . . the 386 . with the release of the 386 in 1985 , many of the issues preventing widespread adoption of the previous protected mode were addressed . the 386 was released with an address bus size of 32 bits , which allows for 2 32 bytes of memory accessing , equivalent to 4 gigabytes . the segment sizes were also increased to 32 bits , meaning that the full address space of 4 gigabytes could be accessed without the need to switch between multiple segments . in addition to the increased size of the address bus and segment registers , many other new features were added with the intention of increasing operational security and stability . protected mode is now used in virtually all modern operating systems which run on the x86 architecture , such as microsoft windows , linux , and many others . furthermore , learning from the failures of the 286 protected mode to satisfy the needs for multiuser dos , intel added a separate virtual 8086 mode , charles petzold , intel 's 32-bit wonder : the 80386 microprocessor , pc magazine , november 25 , 1986 , pp . 150-152 which allowed multiple x86 virtualization to be emulated on the 386 . hardware support required for virtualizing the protected mode itself , however , had to wait for another 20 years . . 386 additions to protected mode . with the release of the 386 , the following additional features were added to protected mode : paging 32-bit physical and virtual address space ( the 32-bit physical address space is not present on the 80386sx , and other 386 processor variants which use the older 286 bus . ) 32-bit segment offsets ability to switch back to real mode without resetting virtual 8086 mode . entering and exiting protected mode . until the release of the 386 , protected mode did not offer a direct method to switch back into real mode once protected mode was entered . ibm devised a workaround ( implemented in the ibm at ) which involved resetting the cpu via the keyboard controller and saving the system registers , call stack and often the interrupt mask in the real-time clock chip 's ram . this allowed the bios to restore the cpu to a similar state and begin executing code before the reset . later , a triple fault was used to reset the 286 cpu , which was a lot faster and cleaner than the keyboard controller method ( and does not depend on ibm at-compatible hardware , but will work on any 80286 cpu in any system ) . to enter protected mode , the global descriptor table ( gdt ) must first be created with a minimum of three entries : a null descriptor , a code segment descriptor and data segment descriptor . in an ibm-compatible machine , the a20 line ( 21st address line ) also must be enabled to allow the use of all the address lines so that the cpu can access beyond 1 megabyte of memory ( only the first 20 are allowed to be used after power-up , to guarantee compatibility with older software written for the intel 8088-based ibm pc and pc/xt models ) . after performing those two steps , the pe bit must be set in the cr0 register and a far jump must be made to clear the prefetch input queue . ; set pe bit mov eax , cr0 or eax , 1 mov cr0 , eax ; far jump ( cs selector of code segment ) jmp cs : pm pm : ; now we are in pm . with the release of the 386 , protected mode could be exited by loading the segment registers with real mode values , disabling the a20 line and clearing the pe bit in the cr0 register , without the need to perform the initial setup steps required with the 286 . features . protected mode has a number of features designed to enhance an operating system 's control over application software , in order to increase security and system stability . these additions allow the operating system to function in a way that would be significantly more difficult or even impossible without proper hardware support . . privilege levels . in protected mode , there are four privilege levels or rings , numbered from 0 to 3 , with ring 0 being the most privileged and 3 being the least . the use of rings allows for system software to restrict tasks from accessing data , call gates or executing privileged instructions . in most environments , the operating system and some device drivers run in ring 0 and applications run in ring 3 . . real mode application compatibility . according to the intel 80286 programmer 's reference manual , for the most part , the binary compatibility with real-mode code , the ability to access up to 16 mb of physical memory , and 1 gb of virtual memory , were the most apparent changes to application programmers . this was not without its limitations . if an application utilized or relied on any of the techniques below , it would not run : segment arithmetic privileged instructions direct hardware access self-modifying code executing data overlapping segments use of bios functions , due to the bios interrupts being reserved by intel in reality , almost all dos application programs violated these rules . due to these limitations , virtual 8086 mode was introduced with the 386 . despite such potential setbacks , windows 3.0 and its successors can take advantage of the binary compatibility with real mode to run many windows 2.x ( windows 2.0 and windows 2.1x ) applications in protected mode , which ran in real mode in windows 2.x . . virtual 8086 mode . with the release of the 386 , protected mode offers what the intel manuals call virtual 8086 mode . virtual 8086 mode is designed to allow code previously written for the 8086 to run unmodified and concurrently with other tasks , without compromising security or system stability . virtual 8086 mode , however , is not completely backwards compatible with all programs . programs that require segment manipulation , privileged instructions , direct hardware access , or use self-modifying code will generate an exception that must be served by the operating system . in addition , applications running in virtual 8086 mode generate a trap with the use of instructions that involve input/output ( i/o ) , which can negatively impact performance . due to these limitations , some programs originally designed to run on the 8086 can not be run in virtual 8086 mode . as a result , system software is forced to either compromise system security or backwards compatibility when dealing with legacy system . an example of such a compromise can be seen with the release of windows nt , which dropped backwards compatibility for '' ill-behaved '' dos applications . . segment addressing . in real mode each logical address points directly into physical memory location , every logical address consists of two 16 bit parts : the segment part of the logical address contains the base address of a segment with a granularity of 16 bytes , i.e . a segment may start at physical address 0 , 16 , 32 , . , 2 20 -16 . the offset part of the logical address contains an offset inside the segment , i.e . the physical address can be calculated as physical_address : segment_part × 16 + offset ( if the address a20 line is enabled ) , respectively ( segment_part × 16 + offset ) mod 2 20 ( if a20 is off ) every segment has a size of 2 16 bytes . protected mode . in protected mode , the is replaced by a 16-bit selector , in which the 13 upper bits ( bit 3 to bit 15 ) contain the index of an entry inside a descriptor table . the next bit ( bit 2 ) specifies whether the operation is used with the gdt or the ldt . the lowest two bits ( bit 1 and bit 0 ) of the selector are combined to define the privilege of the request , where the values of 0 and 3 represent the highest and the lowest privilege , respectively . this means that the byte offset of descriptors in the descriptor table is the same as the 16-bit selector , provided the lower three bits are zeroed . the descriptor table entry defines the real linear address of the segment , a limit value for the segment size , and some attribute bits ( flags ) . 286 . the segment address inside the descriptor table entry has a length of 24 bits so every byte of the physical memory can be defined as bound of the segment . the limit value inside the descriptor table entry has a length of 16 bits so segment length can be between 1 byte and 2 16 byte . the calculated linear address equals the physical memory address . 386 . the segment address inside the descriptor table entry is expanded to 32 bits so every byte of the physical memory can be defined as bound of the segment . the limit value inside the descriptor table entry is expanded to 20 bits and completed with a granularity flag ( g-bit , for short ) : if g-bit is zero limit has a granularity of 1 byte , i.e . segment size may be 1 , 2 , . , 2 20 bytes . if g-bit is one limit has a granularity of 2 12 bytes , i.e . segment size may be 1 × 2 12 , 2 × 2 12 , . , 2 20 × 2 12 bytes . if paging is off , the calculated linear address equals the physical memory address . if paging is on , the calculated linear address is used as input of paging . the 386 processor also uses 32 bit values for the address offset . for maintaining compatibility with 286 protected mode a new default flag ( d-bit , for short ) was added . if the d-bit of a code segment is off ( 0 ) all commands inside this segment will be interpreted as 16-bit commands by default ; if it is on ( 1 ) , they will be interpreted as 32-bit commands . structure of segment descriptor entry . where : a is the accessed bit ; r is the readable bit ; c ( bit 42 ) depends on x : if x 1 then c is the conforming bit , and determines which privilege levels can far-jump to this segment ( without changing privilege level ) : if c 0 then only code with the same privilege level as dpl may jump here ; if c 1 then code with the same or a lower privilege level relative to dpl may jump here . if x 0 then c is the direction bit : if c 0 then the segment grows up ; if c 1 then the segment grows down . x is the executable bit : if x 1 then the segment is a code segment ; if x 0 then the segment is a data segment . s is the segment type bit , which should generally be cleared for system segments ; dpl is the descriptor privilege level ; p is the present bit ; d is the default operand size ; g is the granularity bit ; bit 52 of the 80386 descriptor is not used by the hardware . . paging . in addition to adding virtual 8086 mode , the 386 also added paging to protected mode . through paging , system software can restrict and control a task 's access to pages , which are sections of memory . in many operating systems , paging is used to create an independent virtual address space for each task , preventing one task from manipulating the memory of another . paging also allows for pages to be moved out of primary storage and onto a slower and larger secondary storage , such as a hard disk drive . this allows for more memory to be used than physically available in primary storage . the x86 architecture allows control of pages through two arrays : page directories and page tables . originally , a page directory was the size of one page , four kilobytes , and contained 1,024 page directory entries ( pde ) , although subsequent enhancements to the x86 architecture have added the ability to use larger page sizes . each pde contained a pointer to a page table . a page table was also originally four kilobytes in size and contained 1,024 page table entries ( pte ) . each pte contained a pointer to the actual page 's physical address and are only used when the four-kilobyte pages are used . at any given time , only one page directory may be in active use . . multitasking . through the use of the rings , privileged call gates , and the task state segment ( tss ) , introduced with the 286 , preemptive multitasking was made possible on the x86 architecture . the tss allows general-purpose registers , segment selector fields , and stacks to all be modified without affecting those of another task . the tss also allows a task 's privilege level , and i/o port permissions to be independent of another task 's . in many operating systems , the full features of the tss are not used . this is commonly due to portability concerns or due to the performance issues created with hardware task switches . as a result , many operating systems use both hardware and software to create a multitasking system . . operating systems . operating systems like os/2 1.x try to switch the processor between protected and real modes . this is both slow and unsafe , because a real mode program can easily crash a computer . os/2 1.x defines restrictive programming rules allowing a family api or bound program to run in either real or protected mode . some early unix operating systems , os/2 & nbsp ; 1.x , and windows used this mode . windows & nbsp ; 3.0 was able to run real mode programs in 16-bit protected mode ; when switching to protected mode , it decided to preserve the single privilege level model that was used in real mode , which is why windows applications and dlls can hook interrupts and do direct hardware access . that lasted through the windows 9x series . if a windows 1.x or 2.x program is written properly and avoids segment arithmetic , it will run the same way in both real and protected modes . windows programs generally avoid segment arithmetic because windows implements a software virtual memory scheme , moving program code and data in memory when programs are not running , so manipulating absolute addresses is dangerous ; programs should only keep handles to memory blocks when not running . starting an old program while windows & nbsp ; 3.0 is running in protected mode triggers a warning dialog , suggesting to either run windows in real mode or to obtain an updated version of the application . updating well-behaved programs using the mark utility with the memory parameter avoids this dialog . it is not possible to have some gui programs running in 16-bit protected mode and other gui programs running in real mode . in windows & nbsp ; 3.1 , real mode was no longer supported and could not be accessed . in modern 32-bit operating systems , virtual 8086 mode is still used for running applications , e.g . dpmi compatible dos extender programs ( through virtual dos machines ) or windows & nbsp ; 3.x applications ( through the windows on windows subsystem ) and certain classes of device drivers ( e.g . for changing the screen-resolution using bios functionality ) in os/2 2.0 ( and later os/2 ) and 32-bit windows nt , all under control of a 32-bit kernel . however , 64-bit operating systems ( which run in long mode ) no longer use this , since virtual 8086 mode has been removed from long mode .