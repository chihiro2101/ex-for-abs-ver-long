Symbolic link

overview . a symbolic link contains a text string that is automatically interpreted and followed by the operating system as a path to another file or directory . this other file or directory is called the '' target '' . the symbolic link is a second file that exists independently of its target . if a symbolic link is deleted , its target remains unaffected . if a symbolic link points to a target , and sometime later that target is moved , renamed or deleted , the symbolic link is not automatically updated or deleted , but continues to exist and still points to the old target , now a non-existing location or file . symbolic links pointing to moved or non-existing targets are sometimes called broken , orphaned , dead , or dangling . symbolic links are different from hard links . hard links do not link paths on different volumes or file system , whereas symbolic links may point to any file or directory irrespective of the volumes on which the link and target reside . hard links always refer to an existing file , whereas symbolic links may contain an arbitrary path that does not point to anything . symbolic links operate transparently for many operations : programs that read or write to files named by a symbolic link will behave as if operating directly on the target file . however , they have the effect of changing an otherwise hierarchic filesystem from a tree into a directed graph , which can have consequences for such simple operations as determining the current directory of a process . even the unix standard for navigating to a directory 's parent directory no longer works reliably in the face of symlinks . some shells heuristically try to uphold the illusion of a tree-shaped hierarchy , but when they do , this causes them to produce different results from other programs that manipulate pathnames without such heuristic , relying on the operating system instead . programs that need to handle symbolic links specially ( e.g . , shells and backup utilities ) thus need to identify and manipulate them directly . some unix as well as linux distributions use symbolic links extensively in an effort to reorder the file system hierarchy . this is accomplished with several mechanisms , such as variant , context-dependent symbolic links . this offers the opportunity to create a more intuitive or application-specific directory tree and to reorganize the system without having to redesign the core set of system functions and utilities . posix and unix-like operating systems . in posix-compliant operating systems , symbolic links are created with the symlink symlink , symlinkat . ieee std 1003.1 , 2013 edition . system call . the ln shell command normally uses the link link , linkat . ieee std 1003.1 , 2013 edition . system call , which creates a hard link . when the ln -s flag is specified , the symlink ( ) system call is used instead , creating a symbolic link . symlinks were introduced in 4.2bsd unix from u.c . berkeley . the following command creates a symbolic link at the command-line interface ( shell ) : ln -s target_path link_path target_path is the relative or absolute path to which the symbolic link should point . usually the target will exist , although symbolic links may be created to non-existent targets . link_path is the path of the symbolic link . after creating the symbolic link , it may generally be treated as an alias for the target . any file system management commands ( e.g . , cp , rm ) may be used on the symbolic link . commands which read or write file contents will access the contents of the target file . the rm ( delete file ) command , however , removes the link itself , not the target file . likewise , the mv command moves or renames the link , not the target . the posix directory listing application , ls , denotes symbolic links with an arrow after the name , pointing to the name of the target file ( see following example ) , when the long directory list is requested ( -l option ) . when a directory listing of a symbolic link that points to a directory is requested , only the link itself will be displayed . in order to obtain a listing of the linked directory , the path must include a trailing directory separator character ( '/ ' , slash ) . note : in the example below do not create '' three '' directory before creation of link in /tmp directory . mkdir -p /tmp/one/two echo '' test_a '' > /tmp/one/two/a echo '' test_b '' > /tmp/one/two/b cd /tmp/one/two ls -l -rw-r -- r -- 1 user group 7 jan 01 10:01 a -rw-r -- r -- 1 user group 7 jan 01 10:01 b cd /tmp ln -s /tmp/one/two three ls -l three lrwxrwxrwx 1 user group 12 jul 22 10:02 /tmp/three - > /tmp/one/two ls -l three/ -rw-r -- r -- 1 user group 7 jan 01 10:01 a -rw-r -- r -- 1 user group 7 jan 01 10:01 b cd three ls -l -rw-r -- r -- 1 user group 7 jan 01 10:01 a -rw-r -- r -- 1 user group 7 jan 01 10:01 b cat a test_a cat /tmp/one/two/a test_a echo '' test_c '' > /tmp/one/two/a cat /tmp/one/two/a test_c cat a test_c . storage of symbolic links . early implementations of symbolic links stored the symbolic link information as data in regular files . the file contained the textual reference to the link 's target , and the file mode bits indicated that the type of the file is a symbolic link . this method was slow and an inefficient use of disk-space on small systems . an improvement , called fast symlinks , allowed storage of the target path within the data structures used for storing file information on disk ( inodes ) . this space normally stores a list of disk block addresses allocated to a file . thus , symlinks with short target paths are accessed quickly . systems with fast symlinks often fall back to using the original method if the target path exceeds the available inode space . the original style is retronym a slow symlink . it is also used for disk compatibility with other or older versions of operating systems . although storing the link value inside the inode saves a disk block and a disk read , the operating system still needs to parse the path name in the link , which always requires reading additional inodes and generally requires reading other , and potentially many , directories , processing both the list of files and the inodes of each of them until it finds a match with the link 's path components . only when a link points to a file in the same directory do '' fast symlinks '' provide significantly better performance than other symlinks . the vast majority of posix-compliant implementations use fast symlinks . however , the posix standard does not require the entire set of file status information common to regular files to be implemented for symlinks . this allows implementations to use other solutions , such as storing symlink data in directory entries . the file system permissions of a symbolic link are not used ; the access modes of the target file are controlled by the target file 's own permissions . some operating systems , such as freebsd , offer the ability to modify file permissions and filesystem attributes of a symbolic link , through lchmod and lchflags system calls respectively . the reported size of a symlink is the number of characters in the path it points to . mac os aliases . in mac os , applications or users can also employ aliases , which have the added feature of following the target , even if it is moved to another location on the same volume . this is not to be confused with the shell command alias . microsoft windows . ntfs symbolic link . ntfs 3.1 introduced support for symbolic links for any type of file . it was included with windows xp , but was only enabled by default for kernel mode programs ; windows vista and later versions of windows enabled support for symbolic links to user mode applications , as well , and supplied the command line utility mklink for creating them . third-party drivers are required to enable support for ntfs symbolic links in windows xp . unlike junction points , a symbolic link can also point to a file or remote server message block ( smb ) network path . additionally , the ntfs symbolic link implementation provides full support for cross-filesystem links . however , the functionality enabling cross-host symbolic links requires that the remote system also support them . symbolic links are designed to aid in migration and application compatibility with posix operating systems . microsoft aimed for windows vista 's symbolic links to '' function just like unix links '' . symbolic links , msdn library , win32 and com development , 2008-01-18 however , the implementation varies from unix symbolic links in several ways . for example , windows vista users must manually indicate when creating a symbolic link whether it is a file or a directory . createsymboliclink function , msdn library , win32 and com development windows 7 and vista support a maximum of 31 reparse points ( and therefore symbolic links ) for a given path ( i.e . any given path can have at most 31 indirections before windows gives up ) . symbolic link programming considerations , msdn only users with the new create symbolic link privilege , which only administrators have by default , can create symbolic links . mark russinovich : inside the windows vista kernel : part 1 â€“ file-based symbolic links , microsoft technet , february 2007 . if this is not the desired behavior , it must be changed in the local security policy management console . additionally , ntfs symbolic links to files are distinct from ntfs symbolic links to directories and therefore can not be used interchangeably , unlike on posix where the same symbolic link can refer to either files or directories . in windows vista and later , when the working directory path ends with a symbolic link , the current parent path reference , , will refer to the parent directory of the symbolic link rather than that of its target . this behaviour is also found at the shell level in at least some posix systems , including linux , but never in accessing files and directories through operating system calls . for instance , bash builtin commands and operate on the current logical directory . is often used in scripts to determine the actual current working directory . when any path is used with a system call , any use of will use the actual filesystem parent of the directory containing the pseudo-directory entry . so , and may return completely different results . examples . ps > mklink /d '' env : localappdata\plex media server '' '' g : \plex media server '' ps > new-item -path c : \targetpath -itemtype symboliclink -value f : \sourcepath . ntfs junction points . the windows 2000 version of ntfs introduced reparse points , which enabled , among other things , the use of volume mount points and junction points . junction points are for directories only , and moreover , local directories only ; junction points to remote shares are unsupported . the windows 2000 and xp resource kits include a program called linkd to create junction points ; a more powerful one named junction was distributed by sysinternals ' mark russinovich . not all standard applications support reparse points . most noticeably , backup suffers from this problem and will issue an error message 0x80070003 when the folders to be backed up contain a reparse point . shortcuts . shortcuts , which are supported by the graphical file browsers of some operating systems , may resemble symbolic links but differ in a number of important ways . one difference is what type of software is able to follow them : symbolic links are automatically resolved by the file system . any software program , upon accessing a symbolic link , will see the target instead , whether the program is aware of symbolic links or not . shortcuts are treated like ordinary files by the file system and by software programs that are not aware of them . only software programs that understand shortcuts ( such as the windows shell and file browsers ) treat them as references to other files . another difference are the capabilities of the mechanism : microsoft windows shortcuts normally refer to a destination by an absolute path ( starting from the root directory ) , whereas posix symbolic links can refer to destinations via either an absolute or a relative path . the latter is useful if both the location and destination of the symbolic link share a common path prefix , but that prefix is not yet known when the symbolic link is created ( e.g . , in an archive file that can be unpacked anywhere ) . microsoft windows application shortcuts contain additional metadata that can be associated with the destination , whereas posix symbolic links are just strings that will be interpreted as absolute or relative pathnames . unlike symbolic links , windows shortcuts maintain their references to their targets even when the target is moved or renamed . windows domain clients may subscribe to a windows service called distributed link tracking to track the changes in files and folders to which they are interested . the service maintains the integrity of shortcuts , even when files and folders are moved across the network . additionally , in windows 9x and later , windows shell tries to find the target of a broken shortcut before proposing to delete it . folder shortcuts . almost like shortcuts , but transparent to the windows shell . they are implemented as ordinary folders ( which need to have the read only and/or system attribute unable to remove read-only attribute from folder ) containing a shortcut named target.lnk which refers to the target and a ( hidden ) desktop.ini with ( at least ) the following contents : . shellclassinfo clsid2 . legacy systems . amiga . the command creating symbolic links is makelink , which is also used for hard links . internally the dos.library returns an error code indicating that a target is a soft link if you try to perform actions on it that are only legal for a file , and applications that wish to follow the symbolic link then needs to explicitly make a call to follow the link and retry the operation . the amigados shell will follow links automatically . os/2 . in the os/2 operating system , symbolic links somewhat resemble shadows in the graphical workplace shell . however , shadows , due to the fully object-oriented system object model , are considerably more powerful and robust than a simple link . for example , shadows do not lose their capabilities when renamed or when either the object or subject of the link is relocated . . variable symbolic links . symbolic links may be implemented in a context-dependent or variable fashion , such that the link points to varying targets depending on a configuration parameter , run-time parameter , or other instantaneous condition . a variable or variant symbolic link is a symbolic link that has a variable name embedded in it . this allows some flexibility in filesystem order that is not possible with a standard symbolic link . variables embedded in a symbolic link may include user and environment specific information . operating systems that make use of variant symbolic links include netbsd , dragonfly bsd , domain/os . : magic symlinks . tru64 uses a context dependent symbolic link where the context is the cluster member number . pyramid technology 's osx operating system implemented conditional symbolic links which pointed to different locations depending on which universe a program was running in . the universes supported were at & t 's sysv.3 and the berkeley software distribution ( bsd 4.3 ) . for example : if the ps command was run in the att universe , then the symbolic link for the directory /bin would point to /.attbin and the program /.attbin/ps would be executed . whereas if the ps command was run in the ucb universe , then /bin would point to /.ucbbin and /.ucbbin/ps would be executed . similar conditional symbolic links were also created for other directories such as /lib , /usr/lib , /usr/include . . see also . symlink race & mdash ; a security-vulnerability caused by symbolic links freedup & mdash ; generates links between identical data automatically . references . external links . q & a : the difference between hard and soft links as applied to linux junction : maintain ntfs junction points ( for windows 2000 and above ) fsutil hardlink : microsoft technet page on using the command-line tool fsutil to create hardlinks ( for windows 2000 and above ) link shell extension : windows explorer context menu , overlay icons and property sheet handler to maintain hardlinks , ntfs junction points , symbolic links etc . symbolic drivers for windows xp : file system drivers to enables symbolic links for windows xp ( also mirrored on link shell extension site ) . sources available .