Collision detection

overview . right in physical simulation , experiments , such as playing billiards , are conducted . the physics of bouncing billiard balls are well understood , under the umbrella of rigid body motion and elastic collisions . an initial description of the situation would be given , with a very precise physical description of the billiard table and balls , as well as initial positions of all the balls . given a force applied to the cue ball ( probably resulting from a player hitting the ball with his or her cue stick ) , we want to calculate the trajectories , precise motion , and eventual resting places of all the balls with a computer program . a program to simulate this game would consist of several portions , one of which would be responsible for calculating the precise impacts between the billiard balls . this particular example also turns out to be ill conditioned : a small error in any calculation will cause drastic changes in the final position of the billiard balls . video games have similar requirements , with some crucial differences . while computer simulation needs to simulate real-world physics as precisely as possible , computer games need to simulate real-world physics in an acceptable way , in real time and robustly . compromises are allowed , so long as the resulting simulation is satisfying to the game players . collision detection in computer simulation . physical simulators differ in the way they react on a collision . some use the softness of the material to calculate a force , which will resolve the collision in the following time steps like it is in reality . due to the low softness of some materials this is very cpu intensive . some simulators estimate the time of collision by linear interpolation , roll back the simulation , and calculate the collision by the more abstract methods of conservation laws . some iterate the linear interpolation ( newton 's method ) to calculate the time of collision with a much higher precision than the rest of the simulation . collision detection utilizes time coherence to allow even finer time steps without much increasing cpu demand , such as in air traffic control . after an inelastic collision , special states of sliding and resting can occur and , for example , the open dynamics engine uses constraints to simulate them . constraints avoid inertia and thus instability . implementation of rest by means of a scene graph avoids drift . in other words , physical simulators usually function one of two ways , where the collision is detected a posteriori ( after the collision occurs ) or a priori ( before the collision occurs ) . in addition to the a posteriori and a priori distinction , almost all modern collision detection algorithms are broken into a hierarchy of algorithms . often the terms '' discrete '' and '' continuous '' are used rather than a posteriori and a priori . a posteriori ( discrete ) versus a priori ( continuous ) . in the a posteriori case , the physical simulation is advanced by a small step , then checked to see if any objects are intersecting or visibly considered intersecting . at each simulation step , a list of all intersecting bodies is created , and the positions and trajectories of these objects are '' fixed '' to account for the collision . this method is called a posteriori because it typically misses the actual instant of collision , and only catches the collision after it has actually happened . in the a priori methods , there is a collision detection algorithm which will be able to predict very precisely the trajectories of the physical bodies . the instants of collision are calculated with high precision , and the physical bodies never actually interpenetrate . this is called a priori because the collision detection algorithm calculates the instants of collision before it updates the configuration of the physical bodies . the main benefits of the a posteriori methods are as follows . in this case , the collision detection algorithm need not be aware of the myriad of physical variables ; a simple list of physical bodies is fed to the algorithm , and the program returns a list of intersecting bodies . the collision detection algorithm does n't need to understand friction , elastic collisions , or worse , nonelastic collisions and deformable bodies . in addition , the a posteriori algorithms are in effect one dimension simpler than the a priori algorithms . an a priori algorithm must deal with the time variable , which is absent from the a posteriori problem . on the other hand , a posteriori algorithms cause problems in the '' fixing '' step , where intersections ( which are n't physically correct ) need to be corrected . moreover , if the discrete step is too large , the collision could go undetected , resulting in an object which passes through another if it is sufficiently fast or small . the benefits of the a priori algorithms are increased fidelity and stability . it is difficult ( but not completely impossible ) to separate the physical simulation from the collision detection algorithm . however , in all but the simplest cases , the problem of determining ahead of time when two bodies will collide ( given some initial data ) has no closed form solutionâ€”a numerical root finder is usually involved . some objects are in resting contact , that is , in collision , but neither bouncing off , nor interpenetrating , such as a vase resting on a table . in all cases , resting contact requires special treatment : if two objects collide ( a posteriori ) or slide ( a priori ) and their relative motion is below a threshold , friction becomes stiction and both objects are arranged in the same branch of the scene graph . optimization . the obvious approaches to collision detection for multiple objects are very slow . triangular number will , of course , work , but is too inefficient to be used when the number of objects is at all large . checking objects with complex geometry against each other in the obvious way , by checking each face against each other face , is itself quite slow . thus , considerable research has been applied to speed up the problem . exploiting temporal coherence . in many applications , the configuration of physical bodies from one time step to the next changes very little . many of the objects may not move at all . algorithms have been designed so that the calculations done in a preceding time step can be reused in the current time step , resulting in faster completion of the calculation . at the coarse level of collision detection , the objective is to find pairs of objects which might potentially intersect . those pairs will require further analysis . an early high performance algorithm for this was developed by ming c . lin at the university of california , berkeley who suggested using axis-aligned bounding boxes for all n bodies in the scene . each box is represented by the product of three intervals ( i.e . , a box would be i_1 \times i_2 \times i_3 a_1 , b_1 \times a_2 , b_2 \times a_3 , b_3 ) . a common algorithm for collision detection of bounding boxes is sweep and prune . observe that two such boxes , i_1 \times i_2 \times i_3 and j_1 \times j_2 \times j_3 intersect if and only if , i_1 intersects j_1 , i_2 intersects j_2 and i_3 intersects j_3 . it is supposed that , from one time step to the next , i_k and j_k intersect , then it is very likely that at the next time step they will still intersect . likewise , if they did not intersect in the previous time step , then they are very likely to continue not too . so we reduce the problem to that of tracking , from frame to frame , which intervals do intersect . we have three lists of intervals ( one for each axis ) and all lists are the same length ( since each list has length n , the number of bounding boxes . ) in each list , each interval is allowed to intersect all other intervals in the list . so for each list , we will have an n \times n matrix m ( m_ here the length/distance of the segment is an adjustable '' hit '' criteria size of segment . as the objects approach the length decreases to the threshold value . a triangle sphere becomes the effective geometry test . a sphere centered at the centroid can be sized to encompass all the triangle 's vertices . video games . video games have to split their very limited computing time between several tasks . despite this resource limit , and the use of relatively primitive collision detection algorithms , programmers have been able to create believable , if inexact , systems for use in games . for a long time , video games had a very limited number of objects to treat , and so checking all pairs was not a problem . in two-dimensional games , in some cases , the hardware was able to efficiently detect and report overlapping pixels between sprites on the screen . in other cases , simply tiling the screen and binding each sprite into the tiles it overlaps provides sufficient pruning , and for pairwise checks , bounding rectangles or circles called hitboxes are used and deemed sufficiently accurate . three-dimensional games have used spatial partitioning methods for n -body pruning , and for a long time used one or a few spheres per actual 3d object for pairwise checks . exact checks are very rare , except in games attempting to simulate reality closely . even then , exact checks are not necessarily used in all cases . because games do not need to mimic actual physics , stability is not as much of an issue . almost all games use a posteriori collision detection , and collisions are often resolved using very simple rules . for instance , if a character becomes embedded in a wall , they might be simply moved back to their last known good location . some games will calculate the distance the character can move before getting embedded into a wall , and only allow them to move that far . in many cases for video games , approximating the characters by a point is sufficient for the purpose of collision detection with the environment . in this case , binary space partitioning trees provide a viable , efficient and simple algorithm for checking if a point is embedded in the scenery or not . such a data structure can also be used to handle '' resting position '' situation gracefully when a character is running along the ground . collisions between characters , and collisions with projectiles and hazards , are treated separately . a robust simulator is one that will react to any input in a reasonable way . for instance , if we imagine a high speed racing game , from one simulation step to the next , it is conceivable that the cars would advance a substantial distance along the race track . if there is a shallow obstacle on the track ( such as a brick wall ) , it is not entirely unlikely that the car will completely leap over it , and this is very undesirable . in other instances , the '' fixing '' that posteriori algorithms require is n't implemented correctly , resulting in bugs that can trap characters in walls or allow them to pass through them and fall an endless void where there may or may not be a deadly bottomless pit , sometimes referred to as '' black hell '' , '' blue hell '' , or '' green hell '' , depending on the predominant color . these are the hallmarks of a failing collision detection and physical simulation system . big rigs : over the road racing is an infamous example of a game with a failing or possibly missing collision detection system . hitbox . a hitbox is an invisible shape commonly used in video games for real-time collision detection ; it is a type of bounding box . it is often a rectangle ( in 2d games ) or cuboid ( in 3d ) that is attached to and follows a point on a visible object ( such as a model or a sprite ) . circular or spheroidial shapes are also common , though they are still most often called '' boxes '' . it is common for animated objects to have hitboxes attached to each moving part to ensure accuracy during motion . hitboxes are used to detect '' one-way '' collisions such as a character being hit by a punch or a bullet . they are unsuitable for the detection of collisions with feedback ( e.g . bumping into a wall ) due to the difficulty experienced by both humans and ai in managing a hitbox 's ever-changing locations ; these sorts of collisions are typically handled with much simpler axis-aligned bounding boxes instead . players may use the term '' hitbox '' to refer to these types of interactions regardless . a hurtbox is a related term , used to differentiate '' object that deals damage '' from '' object that receives damage '' . for example , an attack may only land if the hitbox around an attacker 's punch connects with one of the opponent 's hurtboxes on their body , while opposing hitboxes colliding may result in the players trading or cancelling blows , and opposing hurtboxes do not interact with each other . the term is not standardized across the industry ; some games reverse their definitions of '' hitbox '' and '' hurtbox '' , while others only use '' hitbox '' for both sides . see also . hit-testing bounding volume game physics gilbertâ€“johnsonâ€“keerthi distance algorithm minkowski portal refinement physics engine lubachevskyâ€“stillinger algorithm ragdoll physics . references . external links . university of north carolina at chapel hill collision detection research web site prof . steven cameron ( oxford university ) web site on collision detection how to avoid a collision by george beck , wolfram demonstrations project . bounding boxes and their usage separating axis theorem unity 3d collison godot physics collison