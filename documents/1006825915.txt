Reconfigurable computing

history . the concept of reconfigurable computing has existed since the 1960s , when gerald estrin 's paper proposed the concept of a computer made of a standard processor and an array of '' reconfigurable '' hardware . estrin , g . , '' organization of computer systems—the fixed plus variable structure computer '' , proc . western joint computer conf . , western joint computer conference , new york , 1960 , pp . 33–40 . the main processor would control the behavior of the reconfigurable hardware . the latter would then be tailored to perform a specific task , such as image processing or pattern matching , as quickly as a dedicated piece of hardware . once the task was done , the hardware could be adjusted to do some other task . this resulted in a hybrid computer structure combining the flexibility of software with the speed of hardware . in the 1980s and 1990s there was a renaissance in this area of research with many proposed reconfigurable architectures developed in industry and academia , c . bobda : introduction to reconfigurable computing : architectures ; springer , 2007 such as : copacobana , matrix , garp , hauser , john r . and wawrzynek , john , '' garp : a mips processor with a reconfigurable coprocessor '' , proceedings of the ieee symposium on field-programmable custom computing machines ( fccm '97 , april 16–18 , 1997 ) , pp . 24–33 . elixent , ngen , polyp , meregen , pact xpp , silicon hive , montium , pleiades , morphosys , and picoga . campi , f . ; toma , m . ; lodi , a . ; cappelli , a . ; canegallo , r . ; guerrieri , r . , '' a vliw processor with reconfigurable instruction set for embedded applications '' , solid-state circuits conference , 2003 . digest of technical papers . isscc . 2003 ieee international , vol . , no . , pp . 250–491 vol . 1 , 2003 such designs were feasible due to the constant progress of silicon technology that let complex designs be implemented on one chip . some of these massively parallel reconfigurable computers were built primarily for special subdomains such as molecular evolution , neural or image processing . the world 's first commercial reconfigurable computer , the algotronix chs2x4 , was completed in 1991 . it was not a commercial success , but was promising enough that xilinx ( the inventor of the fpga , fpga ) bought the technology and hired the algotronix staff . algotronix history later machines enabled first demonstrations of scientific principles , such as the spontaneous spatial self-organisation of genetic coding with meregen . . theories . tredennick 's classification . the fundamental model of the reconfigurable computing machine paradigm , the data-stream-based anti machine is well illustrated by the differences to other machine paradigms that were introduced earlier , as shown by nick tredennick 's following classification scheme of computing paradigms ( see '' table 1 : nick tredennick ’ s paradigm classification scheme '' ) . n . tredennick : the case for reconfigurable computing ; microprocessor report , vol . 10 no . 10 , 5 august 1996 , pp 25–27 . . hartenstein 's xputer . computer scientist reiner hartenstein describes reconfigurable computing in terms of an anti-machine that , according to him , represents a fundamental paradigm shift away from the more conventional von neumann machine . hartenstein , r . 2001 . a decade of reconfigurable computing : a visionary retrospective . in proceedings of the conference on design , automation and test in europe ( date 2001 ) ( munich , germany ) . w . nebel and a . jerraya , eds . design , automation , and test in europe . ieee press , piscataway , nj , 642–649 . hartenstein calls it reconfigurable computing paradox , that software-to-configware ( software-to-fpga ) migration results in reported speed-up factors of up to more than four orders of magnitude , as well as a reduction in electricity consumption by up to almost four orders of magnitude—although the technological parameters of fpgas are behind the moore 's law by about four orders of magnitude , and the clock frequency is substantially lower than that of microprocessors . this paradox is partly explained by the von neumann syndrome . high-performance computing . high-performance reconfigurable computing ( hprc ) is a computer architecture combining reconfigurable computing-based accelerators like field-programmable gate array with cpus or multi-core processors . the increase of logic in an fpga has enabled larger and more complex algorithms to be programmed into the fpga . the attachment of such an fpga to a modern cpu over a high speed bus , like pci express , has enabled the configurable logic to act more like a coprocessor rather than a peripheral . this has brought reconfigurable computing into the high-performance computing sphere . furthermore , by replicating an algorithm on an fpga or the use of a multiplicity of fpgas has enabled reconfigurable simd systems to be produced where several computational devices can concurrently operate on different data , which is highly parallel computing . this heterogeneous systems technique is used in computing research and especially in supercomputing . n . voros , r . nikolaos , a . rosti , m . hübner ( editors ) : dynamic system reconfiguration in heterogeneous platforms - the morpheus approach ; springer verlag , 2009 a 2008 paper reported speed-up factors of more than 4 orders of magnitude and energy saving factors by up to almost 4 orders of magnitude . some supercomputer firms offer heterogeneous processing blocks including fpgas as accelerators . one research area is the twin-paradigm programming tool flow productivity obtained for such heterogeneous systems . the us national science foundation has a center for high-performance reconfigurable computing ( chrec ) . in april 2011 the fourth many-core and reconfigurable supercomputing conference was held in europe . commercial high-performance reconfigurable computing systems are beginning to emerge with the announcement of ibm integrating fpgas with its power processor . . partial re-configuration . partial re-configuration is the process of changing a portion of reconfigurable hardware circuitry while the other portion keeps its former configuration . field programmable gate arrays are often used as a support to partial reconfiguration . electronic hardware , like software , can be designed modularly , by creating subcomponents and then higher-level components to instantiate them . in many cases it is useful to be able to swap out one or several of these subcomponents while the fpga is still operating . normally , reconfiguring an fpga requires it to be held in reset while an external controller reloads a design onto it . partial reconfiguration allows for critical parts of the design to continue operating while a controller either on the fpga or off of it loads a partial design into a reconfigurable module . partial reconfiguration also can be used to save space for multiple designs by only storing the partial designs that change between designs . a common example for when partial reconfiguration would be useful is the case of a communication device . if the device is controlling multiple connections , some of which require encryption , it would be useful to be able to load different encryption cores without bringing the whole controller down . partial reconfiguration is not supported on all fpgas . a special software flow with emphasis on modular design is required . typically the design modules are built along well defined boundaries inside the fpga that require the design to be specially mapped to the internal hardware . from the functionality of the design , partial reconfiguration can be divided into two groups : dynamic partial reconfiguration , also known as an active partial reconfiguration - permits to change the part of the device while the rest of an fpga is still running ; static partial reconfiguration - the device is not active during the reconfiguration process . while the partial data is sent into the fpga , the rest of the device is stopped ( in the shutdown mode ) and brought up after the configuration is completed . current systems . computer emulation . with the advent of affordable fpga boards , students ' and hobbyists ' projects seek to recreate vintage computers or implement more novel architectures . such projects are built with reconfigurable hardware ( fpgas ) , and some devices support emulation of multiple vintage computers using a single reconfigurable hardware ( c-one ) . copacobana . a fully fpga-based computer is the copacobana , the cost optimized codebreaker and analyzer and its successor rivyera . a spin-off company sciengines gmbh of the copacobana-project of the universities of bochum and kiel in germany continues the development of fully fpga-based computers . mitrionics . mitrionics has developed a sdk that enables software written using a single assignment language to be compiled and executed on fpga-based computers . the mitrion-c software language and mitrion processor enable software developers to write and execute applications on fpga-based computers in the same manner as with other computing technologies , such as graphical processing units ( “ gpus ” ) , cell-based processors , parallel processing units ( “ ppus ” ) , multi-core cpus , and traditional single-core cpu clusters . ( out of business ) . national instruments . national instruments have developed a hybrid embedded computing system called compactrio . it consists of reconfigurable chassis housing the user-programmable fpga , hot swappable i/o modules , real-time controller for deterministic communication and processing , and graphical labview software for rapid rt and fpga programming . xilinx . xilinx has developed two styles of partial reconfiguration of fpga devices : module-based and difference-based . module-based partial reconfiguration permits to reconfigure distinct modular parts of the design , while difference-based partial reconfiguration can be used when a small change is made to a design . intel . intel supports partial reconfiguration of their fpga devices on 28 & nbsp ; nm devices such as stratix v , and on the 20 & nbsp ; nm arria 10 devices . the intel fpga partial reconfiguration flow for arria 10 is based on the hierarchical design methodology in the quartus prime pro software where users create physical partitions of the fpga that can be reconfigured at runtime while the remainder of the design continues to operate . the quartus prime pro software also support hierarchical partial reconfiguration and simulation of partial reconfiguration . classification of systems . as an emerging field , classifications of reconfigurable architectures are still being developed and refined as new architectures are developed ; no unifying taxonomy has been suggested to date . however , several recurring parameters can be used to classify these systems . granularity . the granularity of the reconfigurable logic is defined as the size of the smallest functional unit ( configurable logic block , clb ) that is addressed by the mapping tools . high granularity , which can also be known as fine-grained , often implies a greater flexibility when implementing algorithms into the hardware . however , there is a penalty associated with this in terms of increased power , area and delay due to greater quantity of routing required per computation . fine-grained architectures work at the bit-level manipulation level ; whilst coarse grained processing elements ( reconfigurable datapath unit , rdpu ) are better optimised for standard data path applications . one of the drawbacks of coarse grained architectures are that they tend to lose some of their utilisation and performance if they need to perform smaller computations than their granularity provides , for example for a one bit add on a four bit wide functional unit would waste three bits . this problem can be solved by having a coarse grain array ( reconfigurable datapath array , rdpa ) and a fpga on the same chip . coarse-grained architectures ( rdpa ) are intended for the implementation for algorithms needing word-width data paths ( rdpu ) . as their functional blocks are optimized for large computations and typically comprise word wide arithmetic logic units ( alu ) , they will perform these computations more quickly and with more power efficiency than a set of interconnected smaller functional units ; this is due to the connecting wires being shorter , resulting in less wire capacitance and hence faster and lower power designs . a potential undesirable consequence of having larger computational blocks is that when the size of operands may not match the algorithm an inefficient utilisation of resources can result . often the type of applications to be run are known in advance allowing the logic , memory and routing resources to be tailored to enhance the performance of the device whilst still providing a certain level of flexibility for future adaptation . examples of this are domain specific arrays aimed at gaining better performance in terms of power , area , throughput than their more generic finer grained fpga cousins by reducing their flexibility . rate of reconfiguration . configuration of these reconfigurable systems can happen at deployment time , between execution phases or during execution . in a typical reconfigurable system , a bit stream is used to program the device at deployment time . fine grained systems by their own nature require greater configuration time than more coarse-grained architectures due to more elements needing to be addressed and programmed . therefore , more coarse-grained architectures gain from potential lower energy requirements , as less information is transferred and utilised . intuitively , the slower the rate of reconfiguration the smaller the energy consumption as the associated energy cost of reconfiguration are amortised over a longer period of time . partial re-configuration aims to allow part of the device to be reprogrammed while another part is still performing active computation . partial re-configuration allows smaller reconfigurable bit streams thus not wasting energy on transmitting redundant information in the bit stream . compression of the bit stream is possible but careful analysis is to be carried out to ensure that the energy saved by using smaller bit streams is not outweighed by the computation needed to decompress the data . host coupling . often the reconfigurable array is used as a processing accelerator attached to a host processor . the level of coupling determines the type of data transfers , latency , power , throughput and overheads involved when utilising the reconfigurable logic . some of the most intuitive designs use a peripheral bus to provide a coprocessor like arrangement for the reconfigurable array . however , there have also been implementations where the reconfigurable fabric is much closer to the processor , some are even implemented into the data path , utilising the processor registers . the job of the host processor is to perform the control functions , configure the logic , schedule data and to provide external interfacing . routing/interconnects . the flexibility in reconfigurable devices mainly comes from their routing interconnect . one style of interconnect made popular by fpgas vendors , xilinx and altera are the island style layout , where blocks are arranged in an array with vertical and horizontal routing . a layout with inadequate routing may suffer from poor flexibility and resource utilisation , therefore providing limited performance . if too much interconnect is provided this requires more transistors than necessary and thus more silicon area , longer wires and more power consumption . challenges for operating systems . one of the key challenges for reconfigurable computing is to enable higher design productivity and provide an easier way to use reconfigurable computing systems for users that are unfamiliar with the underlying concepts . one way of doing this is to provide standardization and abstraction , usually supported and enforced by an operating system . this article contains quotations from this source , which is available under the creative commons attribution 4.0 international ( cc by 4.0 ) license . one of the major tasks of an operating system is to hide the hardware and present programs ( and their programmers ) with nice , clean , elegant , and consistent abstractions to work with instead . in other words , the two main tasks of an operating system are abstraction and resource management . abstraction is a powerful mechanism to handle complex and different ( hardware ) tasks in a well-defined and common manner . one of the most elementary os abstractions is a process . a process is a running application that has the perception ( provided by the os ) that it is running on its own on the underlying virtual hardware . this can be relaxed by the concept of threads , allowing different tasks to run concurrently on this virtual hardware to exploit task level parallelism . to allow different processes and threads to coordinate their work , communication and synchronization methods have to be provided by the os . in addition to abstraction , resource management of the underlying hardware components is necessary because the virtual computers provided to the processes and threads by the operating system need to share available physical resources ( processors , memory , and devices ) spatially and temporarily . . see also . computing with memory glossary of reconfigurable computing iland project m-labs 1chipmsx piperench psoc sprinter