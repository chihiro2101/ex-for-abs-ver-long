High-level programming language

features . '' high-level language '' refers to the higher level of abstraction from machine language . rather than dealing with registers , memory addresses , and call stacks , high-level languages deal with variables , arrays , objects , complex arithmetic or boolean expressions , subroutines and functions , loops , threads , locks , and other abstract computer science concepts , with a focus on usability over optimal program efficiency . unlike low-level assembly languages , high-level languages have few , if any , language elements that translate directly into a machine 's native opcodes . other features , such as string handling routines , object-oriented language features , and file input/output , may also be present . one thing to note about high-level programming languages is that these languages allow the programmer to be detached and separated from the machine . that is , unlike low-level languages like assembly or machine language , high-level programming can amplify the programmer 's instructions and trigger a lot of data movements in the background without their knowledge . the responsibility and power of executing instructions have been handed over to the machine from the programmer . abstraction penalty . high-level languages intend to provide features which standardize common tasks , permit rich debugging , and maintain architectural agnosticism ; while low-level languages often produce more efficient code through optimization for a specific system architecture . abstraction penalty is the cost that high-level programming techniques pay for being unable to optimize performance or use certain hardware because they do n't take advantage of certain low-level architectural resources . high-level programming exhibits features like more generic data structures and operations , run-time interpretation , and intermediate code files ; which often result in execution of far more operations than necessary , higher memory consumption , and larger binary program size . for this reason , code which needs to run particularly quickly and efficiently may require the use of a lower-level language , even if a higher-level language would make the coding easier . in many cases , critical portions of a program mostly in a high-level language can be hand-coded in assembly language , leading to a much faster , more efficient , or simply reliably functioning optimised program . however , with the growing complexity of modern microprocessor architectures , well-designed compilers for high-level languages frequently produce code comparable in efficiency to what most low-level programmers can produce by hand , and the higher abstraction may allow for more powerful techniques providing better overall results than their low-level counterparts in particular settings . high-level languages are designed independent of a specific computing system architecture . this facilitates executing a program written in such a language on any computing system with compatible support for the interpreted or jit program . high-level languages can be improved as their designers develop improvements . in other cases , new high-level languages evolve from one or more others with the goal of aggregating the most popular constructs with new or improved features . an example of this is scala which maintains backward compatibility with java which means that programs and libraries written in java will continue to be usable even if a programming shop switches to scala ; this makes the transition easier and the lifespan of such high-level coding indefinite . in contrast , low-level programs rarely survive beyond the system architecture which they were written for without major revision . this is the engineering 'trade-off ' for the 'abstraction penalty ' . relative meaning . examples of high-level programming languages in active use today include python , visual basic , delphi , perl , php , ecmascript , ruby , c , java and many others . the terms high-level and low-level are inherently relative . some decades ago , the c language , and similar languages , were most often considered '' high-level '' , as it supported concepts such as expression evaluation , parameterised recursive functions , and data types and structures , while assembly language was considered '' low-level '' . today , many programmers might refer to c as low-level , as it lacks a large runtime-system ( no garbage collection , etc . ) , basically supports only scalar operations , and provides direct memory addressing . it , therefore , readily blends with assembly language and the machine level of cpus and microcontrollers . assembly language may itself be regarded as a higher level ( but often still one-to-one if used without macros ) representation of machine code , as it supports concepts such as constants and ( limited ) expressions , sometimes even variables , procedures , and data structures . machine code , in its turn , is inherently at a slightly higher level than the microcode or micro-operations used internally in many processors . . execution modes . there are three general modes of execution for modern high-level languages : ; interpreted : when code written in a language is interpreted , its syntax is read and then executed directly , with no compilation stage . a program called an interpreter reads each program statement , following the program flow , then decides what to do , and does it . a hybrid of an interpreter and a compiler will compile the statement into machine code and execute that ; the machine code is then discarded , to be interpreted anew if the line is executed again . interpreters are commonly the simplest implementations of the behavior of a language , compared to the other two variants listed here . ; compiled : when code written in a language is compiled , its syntax is transformed into an executable form before running . there are two types of compilation : : ; machine code generation : some compilers compile source code directly into machine code . this is the original mode of compilation , and languages that are directly and completely transformed to machine-native code in this way may be called truly compiled languages . see assembly language . : ; intermediate representations : when code written in a language is compiled to an intermediate representation , that representation can be optimized or saved for later execution without the need to re-read the source file . when the intermediate representation is saved , it may be in a form such as bytecode . the intermediate representation must then be interpreted or further compiled to execute it . virtual machines that execute bytecode directly or transform it further into machine code have blurred the once clear distinction between intermediate representations and truly compiled languages . ; source-to-source translated or transcompiled : code written in a language may be translated into terms of a lower-level language for which native code compilers are already common . javascript and the language c are common targets for such translators . see coffeescript , chicken scheme , and eiffel as examples . specifically , the generated c and c++ code can be seen ( as generated from the eiffel language when using the eiffelstudio ide ) in the eifgens directory of any compiled eiffel project . in eiffel , the translated process is referred to as transcompiling or transcompiled , and the eiffel compiler as a transcompiler or source-to-source compiler . note that languages are not strictly interpreted languages or compiled languages . rather , implementations of language behavior use interpreting or compiling . for example , algol 60 and fortran have both been interpreted ( even though they were more typically compiled ) . similarly , java shows the difficulty of trying to apply these labels to languages , rather than to implementations ; java is compiled to bytecode which is then executed by either interpreting ( in a java virtual machine ( jvm ) ) or compiling ( typically with a just-in-time compiler such as hotspot , again in a jvm ) . moreover , compiling , transcompiling , and interpreting is not strictly limited to only a description of the compiler artifact ( binary executable or il assembly ) . high-level language computer architecture . alternatively , it is possible for a high-level language to be directly implemented by a computer – the computer directly executes the hll code . this is known as a high-level language computer architecture – the computer architecture itself is designed to be targeted by a specific high-level language . the burroughs large systems were target machines for algol 60 , for example .