Link-state routing protocol

history . what is believed to be the first adaptive routing network of computers , using link-state routing as its heart , was designed and implemented during 1976-77 by a team from plessey radar led by bernard j harris ; the project was for '' wavell '' - a system of computer command and control for the british army . the first link-state routing concept was published in 1979 by john m . mcquillan ( then at bolt , beranek and newman ) as a mechanism that would calculate routes more quickly when network conditions changed , and thus lead to more stable routing . john m . mcquillan , isaac richer and eric c . rosen , arpanet routing algorithm improvements , bbn report no . 3803 , cambridge , april 1978 john m . mcquillan , isaac richer and eric c . rosen , the new routing algorithm for the arpanet , ieee trans . on comm . , 28 ( 5 ) , pp . & nbsp ; 711–719 , 1980 later work at bbn technologies showed how to use the link-state technique in a hierarchical system ( i.e . , one in which the network was divided into areas ) so that each switching node does not need a map of the entire network , only the area ( s ) in which it is included . the technique was later adapted for use in the contemporary link-state routing protocols is-is and ospf . cisco literature refers to enhanced interior gateway routing protocol ( eigrp ) as a '' hybrid '' protocol , despite the fact it distributes routing tables instead of topology maps . however , it does synchronize routing tables at start up as ospf does , and sends specific updates only when topology changes occur . in 2004 , radia perlman proposed using link-state routing for layer 2 frame forwarding with devices called routing bridges or rbridges . the internet engineering task force has standardized the trill ( computer networking ) ( trill ) protocol to accomplish this . more recently , this hierarchical technique was applied to wireless mesh networks using the optimized link state routing protocol ( olsr ) . where a connection can have varying quality , the quality of a connection can be used to select better connections . this is used in some routing protocols that use radio frequency transmission . in 2012 , the ieee completed and approved the standardization of the use of is-is to control ethernet forwarding with ieee 802.1aq shortest path bridging ( spb ) . distributing maps . this description covers only the simplest configuration ; i.e . , one with no areas , so that all nodes have a map of the entire network . the hierarchical case is somewhat more complex ; see the various protocol specifications . as previously mentioned , the first main stage in the link-state algorithm is to give a map of the network to every node . this is done with several subsidiary steps . determining the neighbours of each node . first , each node needs to determine what other ports it is connected to , over fully working links ; it does this using a reachability protocol which it runs periodically and separately with each of its directly connected neighbours . distributing the information for the map . next , each node periodically ( and in case of connectivity changes ) sends a short message , the link-state advertisement , which : identifies the node which is producing it . identifies all the other nodes ( either routers or networks ) to which it is directly connected . includes a 'sequence number ' , which increases every time the source node makes up a new version of the message . this message is sent to all the nodes on a network . as a necessary precursor , each node in the network remembers , for every one of its neighbors , the sequence number of the last link-state message which it received from that node . when a link-state advertisement is received at a node , the node looks up the sequence number it has stored for the source of that link-state message : if this message is newer ( i.e . , has a higher sequence number ) , it is saved , the sequence number is updated , and a copy is sent in turn to each of that node 's neighbors . this procedure rapidly gets a copy of the latest version of each node 's link-state advertisement to every node in the network . networks running link state algorithms can also be segmented into hierarchies which limit the scope of route changes . these features mean that link state algorithms scale better to larger networks . creating the map . finally , with the complete set of link-state advertisements ( one from each node in the network ) in hand , each node produces the graph for the map of the network . the algorithm iterates over the collection of link-state advertisements ; for each one , it makes links on the map of the network , from the node which sent that message , to all the nodes which that message indicates are neighbors of the sending node . no link is considered to have been correctly reported unless the two ends agree ; i.e . , if one node reports that it is connected to another , but the other node does not report that it is connected to the first , there is a problem , and the link is not included on the map . notes about this stage . the link-state message giving information about the neighbors is recomputed , and then flooded throughout the network , whenever there is a change in the connectivity between the node and its neighbors ; e.g . , when a link fails . any such change will be detected by the reachability protocol which each node runs with its neighbors . calculating the routing table . as initially mentioned , the second main stage in the link-state algorithm is to produce routing tables , by inspecting the maps . this is again done with several steps . calculating the shortest paths . each node independently runs an algorithm over the map to determine the shortest path from itself to every other node in the network ; generally some variant of dijkstra 's algorithm is used . this is based around a link cost across each path which includes available bandwidth among other things . a node maintains two data structures : a tree containing nodes which are '' done '' , and a list of candidates . the algorithm starts with both structures empty ; it then adds to the first one the node itself . the variant of a greedy algorithm then repetitively does the following : all neighbour nodes which are directly connected to the node are just added to the tree ( excepting any nodes which are already in either the tree or the candidate list ) . the rest are added to the second ( candidate ) list . each node in the candidate list is compared to each of the nodes already in the tree . the candidate node which is closest to any of the nodes already in the tree is itself moved into the tree and attached to the appropriate neighbor node . when a node is moved from the candidate list into the tree , it is removed from the candidate list and is not considered in subsequent iterations of the algorithm . the above two steps are repeated as long as there are any nodes left in the candidate list . ( when there are none , all the nodes in the network will have been added to the tree . ) this procedure ends with the tree containing all the nodes in the network , with the node on which the algorithm is running as the root of the tree . the shortest path from that node to any other node is indicated by the list of nodes one traverses to get from the root of the tree , to the desired node in the tree . ! . filling the routing table . with the shortest paths in hand , the next step is to fill in the routing table . for any given destination node , the best path for that destination is the node which is the first step from the root node , down the branch in the shortest-path tree which leads toward the desired destination node . to create the routing table , it is only necessary to walk the tree , remembering the identity of the node at the head of each branch , and filling in the routing table entry for each node one comes across with that identity . optimizations to the algorithm . the algorithm described above was made as simple as possible , to aid in ease of understanding . in practice , there are a number of optimizations which are used . partial recomputation . whenever a change in the connectivity map happens , it is necessary to recompute the shortest-path tree , and then recreate the routing table . work by bbn technologies discovered how to recompute only that part of the tree which could have been affected by a given change in the map . also , the routing table would normally be filled in as the shortest-path tree is computed , instead of making it a separate operation . topology reduction . in some cases it is reasonable to reduce the number of nodes that generate lsa messages . for instance , a node that has only one connection to the network graph does not need to send lsa messages , as the information on its existence could be already included in the lsa message of its only neighbor . for this reason a topology reduction strategy can be applied , in which only a subset of the network nodes generate lsa messages . two widely studied approaches for topology reduction are : multipoint relays that are at the base of the olsr protocol but have also been proposed for ospf connected_dominating_set that again have been proposed for ospf . fisheye state routing . with fsr the lsa are sent with different ttl values in order to restrict their diffusion and limit the overhead due to control messages . the same concept is used also in the hazy sighted link state routing protocol . failure modes . if all the nodes are not working from exactly the same map , routing loops can form . these are situations in which , in the simplest form , two neighboring nodes each think the other is the best path to a given destination . any packet headed to that destination arriving at either node will loop between the two , hence the name . routing loops involving more than two nodes are also possible . this can occur since each node computes its shortest-path tree and its routing table without interacting in any way with any other nodes . if two nodes start with different maps , it is possible to have scenarios in which routing loops are created . in certain circumstances , differential loops may be enabled within a multi cloud environment . variable access nodes across the interface protocol may also bypass the simultaneous access node problem . . the optimized link state routing protocol for mobile ad hoc networks . the optimized link state routing protocol ( olsr ) is a link-state routing protocol optimized for mobile ad hoc networks ( which can also be used on other wireless ad hoc networks ) . rfc 3626 olsr is proactive , it uses hello and topology control ( tc ) messages to discover and disseminate link state information into the mobile ad hoc network . using hello messages each node discovers 2-hop neighbor information and elects a set of multipoint relays ( mprs ) . mprs makes olsr unique from other link state routing protocols . individual nodes use the topology information to compute next hop paths regard to all nodes in the network using shortest hop forwarding paths . see also . ieee 802.1aq . references . josh seeger and atul khanna , reducing routing overhead in a growing ddn , milcomm '86 , ieee , 1986 radia perlman “ rbridges : transparent routing ” , infocom 2004 . further reading . section '' link-state versus distance vector '' in the chapter '' routing basics '' in the cisco '' internetworking technology handbook ''