Formal methods

background . semi-formal methods are formalisms and languages that are not considered fully “ formal ” . it defers the task of completing the semantics to a later stage , which is then done either by human interpretation or by interpretation through software like code or test case generators . . taxonomy . formal methods can be used at a number of levels : level 0 : formal specification may be undertaken and then a program developed from this informally . this has been dubbed formal methods lite . this may be the most cost-effective option in many cases . level 1 : formal development and formal verification may be used to produce a program in a more formal manner . for example , proofs of properties or refinement from the specification to a program may be undertaken . this may be most appropriate in high-integrity systems involving safety or security . level 2 : theorem provers may be used to undertake fully formal machine-checked proofs . this can be very expensive and is only practically worthwhile if the cost of mistakes is extremely high ( e.g . , in critical parts of microprocessor design ) . further information on this is expanded uses . as with programming language semantics , styles of formal methods may be roughly classified as follows : denotational semantics , in which the meaning of a system is expressed in the mathematical theory of domains . proponents of such methods rely on the well-understood nature of domains to give meaning to the system ; critics point out that not every system may be intuitively or naturally viewed as a function . operational semantics , in which the meaning of a system is expressed as a sequence of actions of a ( presumably ) simpler computational model . proponents of such methods point to the simplicity of their models as a means to expressive clarity ; critics counter that the problem of semantics has just been delayed ( who defines the semantics of the simpler model ? ) . axiomatic semantics , in which the meaning of the system is expressed in terms of preconditions and postconditions which are true before and after the system performs a task , respectively . proponents note the connection to classical logic ; critics note that such semantics never really describe what a system does ( merely what is true before and afterwards ) . lightweight formal methods . some practitioners believe that the formal methods community has overemphasized full formalization of a specification or design . daniel jackson and jeannette wing , '' lightweight formal methods '' , ieee computer , april 1996 vinu george and rayford vaughn , '' application of lightweight formal methods in requirement engineering '' , crosstalk : the journal of defense software engineering , january 2003 they contend that the expressiveness of the languages involved , as well as the complexity of the systems being modelled , make full formalization a difficult and expensive task . as an alternative , various lightweight formal methods , which emphasize partial specification and focused application , have been proposed . examples of this lightweight approach to formal methods include the alloy object modelling notation , daniel jackson , '' alloy : a lightweight object modelling notation '' , acm transactions on software engineering and methodology ( tosem ) , volume 11 , issue 2 ( april 2002 ) , pp . 256-290 denney 's synthesis of some aspects of the z notation with use case driven development , richard denney , succeeding with use cases : working smart to deliver quality , addison-wesley professional publishing , 2005 , . and the csk vdm tools . sten agerholm and peter g . larsen , '' a lightweight approach to formal methods '' , in proceedings of the international workshop on current trends in applied formal methods , boppard , germany , springer-verlag , october 1998 . uses . formal methods can be applied at various points through the development process . specification . formal methods may be used to give a description of the system to be developed , at whatever level ( s ) of detail desired . this formal description can be used to guide further development activities ( see following sections ) ; additionally , it can be used to verify that the requirements for the system being developed have been completely and accurately specified , or formalising system requirements by expressing them in a formal language with a precise and unambiguously defined syntax and semantics . the need for formal specification systems has been noted for years . in the algol 58 report , john backus presented a formal notation for describing programming language syntax , later named backus normal form then renamed backus–naur form ( bnf ) . donald knuth ( 1964 ) , backus normal form vs backus naur form . communications of the acm , 7 ( 12 ) :735–736 . backus also wrote that a formal description of the meaning of syntactically valid algol programs was n't completed in time for inclusion in the report . '' therefore the formal treatment of the semantics of legal programs will be included in a subsequent paper . '' it never appeared . development . formal development is the use of formal methods as an integrated part of a tool-supported system development process . once a formal specification has been produced , the specification may be used as a guide while the concrete system is developed during the design process ( i.e . , realized typically in software , but also potentially in hardware ) . for example : if the formal specification is in operational semantics , the observed behavior of the concrete system can be compared with the behavior of the specification ( which itself should be executable or simulatable ) . additionally , the operational commands of the specification may be amenable to direct translation into executable code . if the formal specification is in axiomatic semantics , the preconditions and postconditions of the specification may become assertions in the executable code . verification . formal verification is the use of software tools to prove properties of a formal specification , or to prove that a formal model of a system implementation satisfies its specification . once a formal specification has been developed , the specification may be used as the basis for proving properties of the specification ( and hopefully by inference the developed system ) . sign-off verification . sign-off verification is the use of a formal verification tool that is highly trusted . such a tool can replace traditional verification methods ( the tool may even be certified ) . human-directed proof . sometimes , the motivation for proving the correctness of a system is not the obvious need for reassurance of the correctness of the system , but a desire to understand the system better . consequently , some proofs of correctness are produced in the style of mathematical proof : handwritten ( or typeset ) using natural language , using a level of informality common to such proofs . a '' good '' proof is one that is readable and understandable by other human readers . critics of such approaches point out that the ambiguity inherent in natural language allows errors to be undetected in such proofs ; often , subtle errors can be present in the low-level details typically overlooked by such proofs . additionally , the work involved in producing such a good proof requires a high level of mathematical sophistication and expertise . automated proof . in contrast , there is increasing interest in producing proofs of correctness of such systems by automated means . automated techniques fall into three general categories : automated theorem proving , in which a system attempts to produce a formal proof from scratch , given a description of the system , a set of logical axioms , and a set of inference rules . model checking , in which a system verifies certain properties by means of an exhaustive search of all possible states that a system could enter during its execution . abstract interpretation , in which a system verifies an over-approximation of a behavioural property of the program , using a fixpoint computation over a ( possibly complete ) lattice representing it . some automated theorem provers require guidance as to which properties are '' interesting '' enough to pursue , while others work without human intervention . model checkers can quickly get bogged down in checking millions of uninteresting states if not given a sufficiently abstract model . proponents of such systems argue that the results have greater mathematical certainty than human-produced proofs , since all the tedious details have been algorithmically verified . the training required to use such systems is also less than that required to produce good mathematical proofs by hand , making the techniques accessible to a wider variety of practitioners . critics note that some of those systems are like oracles : they make a pronouncement of truth , yet give no explanation of that truth . there is also the problem of '' verifying the verifier '' ; if the program which aids in the verification is itself unproven , there may be reason to doubt the soundness of the produced results . some modern model checking tools produce a '' proof log '' detailing each step in their proof , making it possible to perform , given suitable tools , independent verification . the main feature of the abstract interpretation approach is that it provides a sound analysis , i.e . no false negatives are returned . moreover , it is efficiently scalable , by tuning the abstract domain representing the property to be analyzed , and by applying widening operators a . cortesi and m . zanioli , widening and narrowing operators for abstract interpretation . computer languages , systems and structures . volume 37 ( 1 ) , pp . 24–42 , elsevier , ( 2011 ) . to get fast convergence . applications . formal methods are applied in different areas of hardware and software , including routers , ethernet switches , routing protocols , security applications , and operating system microkernels such as sel4 . there are several examples in which they have been used to verify the functionality of the hardware and software used in dcs . ibm used acl2 , a theorem prover , in the amd x86 processor development process . intel uses such methods to verify its hardware and firmware ( permanent software programmed into a read-only memory ) . dansk datamatik center used formal methods in the 1980s to develop a compiler system for the ada programming language that went on to become a long-lived commercial product . there are several other projects of nasa in which formal methods are applied , such as next generation air transportation system , unmanned aircraft system integration in national airspace system , gheorghe , a . v . , & ancel , e . ( 2008 , november ) . unmanned aerial systems integration to national airspace system . in infrastructure systems and services : building networks for a brighter future ( infra ) , 2008 first international conference on ( pp . 1-5 ) . ieee . and airborne coordinated conflict resolution and detection ( accord ) . airborne coordinated conflict resolution and detection , b-method with atelier b , is used to develop safety automatisms for the various subways installed throughout the world by alstom and siemens , and also for common criteria certification and the development of system models by atmel and stmicroelectronics . formal verification has been frequently used in hardware by most of the well-known hardware vendors , such as ibm , intel , and amd . there are many areas of hardware , where intel have used fms to verify the working of the products , such as parameterized verification of cache-coherent protocol , c . t . chou , p . k . mannava , s . park , “ a simple method for parameterized verification of cache coherence protocols ” , formal methods in computer-aided design , pp . 382–398 , 2004 . intel core i7 processor execution engine validation formal verification in intel® core™ i7 processor execution engine validation , accessed at sep . 13 , 2013 . ( using theorem proving , bdds , and symbolic evaluation ) , optimization for intel ia-64 architecture using hol light theorem prover , j . grundy , “ verified optimizations for the intel ia-64 architecture ” , in theorem proving in higher order logics , springer berlin heidelberg , 2004 , pp . 215–232 . and verification of high-performance dual-port gigabit ethernet controller with support for pci express protocol and intel advance management technology using cadence . e . seligman , i . yarom , “ best known methods for using cadence conformal lec ” , at intel . similarly , ibm has used formal methods in the verification of power gates , c . eisner , a . nahir , k . yorav , “ ftp : //nozdr.ru/biblio/kolxo3/cs/csln/computer % 20aided % 20verification , % 2020 % 20conf . , % 20cav % 202008 ( lncs5123 , % 20springer , % 202008 ) ( isbn % 209783540705437 ) ( 573s ) _csln_.pdf page 449 functional verification of power gated designs by compositional reasoning ” , computer aided verification , springer berlin heidelberg , pp . 433–445 . registers , p . c . attie , h . chockler , “ automatic verification of fault-tolerant register emulations ” , electronic notes in theoretical computer science , vol . 149 , no . 1 , pp . 49–60 . and functional verification of the ibm power7 microprocessor . k . d . schubert , w . roesner , j . m . ludden , j . jackson , j . buchert , v . paruthi , b . brock , “ functional verification of the ibm power7 microprocessor and power7 multiprocessor systems ” , ibm journal of research and development , vol . 55 , no 3 . . in software development . in software development , formal methods are mathematical approaches to solving software ( and hardware ) problems at the requirements , specification , and design levels . formal methods are most likely to be applied to safety-critical or security-critical software and systems , such as avionics software . software safety assurance standards , such as do-178c allows the usage of formal methods through supplementation , and common criteria mandates formal methods at the highest levels of categorization . for sequential software , examples of formal methods include the b-method , the specification languages used in automated theorem proving , raise , and the z notation . in functional programming , quickcheck has allowed the mathematical specification and testing ( if not exhaustive testing ) of the expected behaviour of individual functions . the object constraint language ( and specializations such as java modeling language ) has allowed object-oriented systems to be formally specified , if not necessarily formally verified . for concurrent software and systems , petri nets , process algebra , and finite state machines ( which are based on automata theory - see also virtual finite state machine or event driven finite state machine ) allow executable software specification and can be used to build up and validate application behaviour . another approach to formal methods in software development is to write a specification in some form of logic—usually a variation of first-order logic ( fol ) —and then to directly execute the logic as though it were a program . the owl language , based on description logic ( dl ) , is an example . there is also work on mapping some version of english ( or another natural language ) automatically to and from logic , as well as executing the logic directly . examples are attempto controlled english , and internet business logic , which do not seek to control the vocabulary or syntax . a feature of systems that support bidirectional english-logic mapping and direct execution of the logic is that they can be made to explain their results , in english , at the business or scientific level . formal methods and notations . there are a variety of formal methods and notations available . specification languages . abstract state machines ( asms ) acl2 ( acl2 ) actor model alloy ansi/iso c specification language ( acsl ) autonomic system specification language ( assl ) b-method cadp common algebraic specification language ( casl ) esterel java modeling language ( jml ) knowledge based software assistant ( kbsa ) lustre mcrl2 perfect developer petri nets predicative programming process calculi csp lotos π-calculus raise rebeca modeling language spark ada spec sharp ( spec ) specification and description language tla+ usl vdm vdm-sl vdm++ z notation . model checkers . esbmc malpas software static analysis toolset – an industrial-strength model checker used for formal proof of safety-critical systems pat – a free model checker , simulator and refinement checker for concurrent systems and csp extensions ( e.g . , shared variables , arrays , fairness ) spin uppaal . organizations . apcb bcs-facs formal methods europe z user group . see also . abstract interpretation automated theorem proving design by contract formal methods people formal specification formal verification formal system model checking software engineering specification language . references . . further reading . jonathan p . bowen and michael g . hinchey , formal methods . in allen b . tucker , jr . ( ed . ) , computer science handbook , 2nd edition , section xi , software engineering , chapter 106 , pages 106-1 & nbsp ; – 106-25 , chapman & hall / crc press , association for computing machinery , 2004 . hubert garavel ( editor ) and susanne graf . formal methods for safe and secure computer systems . federal office for information security , bsi study 875 , bonn , germany , december 2013 . michael g . hinchey , jonathan p . bowen , and emil vassev , formal methods . in philip a . laplante ( ed . ) , encyclopedia of software engineering , taylor & francis , 2010 , pages 308–320 . marieke huisman , dilian gurov , and alexander malkis , formal methods : from academia to industrial practice – a travel guide , arxiv:2002.07279 , 2020 . jean françois monin and michael g . hinchey , understanding formal methods , springer , 2003 , . external links . formal methods europe ( fme ) formal methods wiki formal methods from foldoc ; archival material formal method keyword on microsoft academic search via archive.org evidence on formal methods uses and impact on industry supported by the deploy project ( eu fp7 ) in archive.org