Common Lisp Object System

features . the basic building blocks of clos are methods , classes , instances of those classes , and generic functions . clos provides macros to define those : defclass , defmethod , and defgeneric . instances are created with the method make-instance . classes can have multiple superclasses , a list of slots ( member variables in c++/java parlance ) and a special metaclass . slots can be allocated by class ( all instances of a class share the slot ) or by instance . each slot has a name and the value of a slot can be accessed by that name using the function slot-value . additionally special generic functions can be defined to write or read values of slots . each slot in a clos class must have a unique name . clos is a multiple dispatch system . this means that methods can be specialized upon any or all of their required arguments . most oo languages are single-dispatch , meaning that methods are only specialized on the first argument . another unusual feature is that methods do not '' belong '' to classes ; classes do not provide a namespace for generic functions or methods . methods are defined separately from classes , and they have no special access ( e.g . '' this '' , '' self '' , or '' protected '' ) to class slots . methods in clos are grouped into generic functions . a generic function is an object which is callable like a function and which associates a collection of methods with a shared name and argument structure , each specialized for different arguments . since common lisp provides non-clos classes for structures and built-in data types ( numbers , strings , characters , symbols , . ) , clos dispatch works also with these non-clos classes . clos also supports dispatch over individual objects ( eql specializers ) . clos does not by default support dispatch over all common lisp data types ( for example dispatch does not work for fully specialized array types or for types introduced by deftype ) . however , most common lisp implementations provide a metaobject protocol which allows generic functions to provide application specific specialization and dispatch rules . dispatch in clos is also different from most oo languages : given a list of arguments , a list of applicable methods is determined . this list is sorted according to the specificity of their parameter specializers . selected methods from this list are then combined into an effective method using the method combination used by the generic function . the effective method is then called with the original arguments . this dispatch mechanism works at runtime . adding or removing methods thus may lead to changed effective methods ( even when the generic function is called with the same arguments ) at runtime . changing the method combination also may lead to different effective methods . for example , ; declare the common argument structure prototype ( defgeneric f ( x y ) ) ; define an implementation for ( f integer t ) , where t matches all types ( defmethod f ( ( x integer ) y ) 1 ) ( f 1 2.0 ) > 1 ; define an implementation for ( f integer real ) ( defmethod f ( ( x integer ) ( y real ) ) 2 ) ( f 1 2.0 ) > 2 ; dispatch changed at runtime like the oo systems in most dynamic languages , clos does not enforce encapsulation . any slot can be accessed using the slot-value function or via ( optionally auto-generated ) accessor methods . to access it via slot-value you have to know the name of the slot . cl programmers use the language 's package facility to declare which functions or data structures are intended for export . apart from normal ( '' primary '' ) methods , there also are : before , : after , and : around '' auxiliary '' methods . the former two are invoked prior to , or after the primary method , in a particular order based on the class hierarchy . an : around method can control whether the primary method is executed at all . additionally , the programmer can specify whether all possible primary methods along the class hierarchy should be called or just the one providing the closest match . the standard method-combination provides the primary , before , after and around methods explained above . there are other method-combinations with other method types . new ( both simple and complex ) method-combinations and method types can be defined . clos allows multiple inheritance . when the default order in which methods are executed in multiple inheritance is not correct , the programmer may resolve the diamond problem by specifying the order of method combinations . clos is dynamic , meaning that not only the contents , but also the structure of its objects can be modified at runtime . clos supports changing class definitions on-the-fly ( even when instances of the class in question already exist ) as well as changing the class membership of a given instance through the change-class operator . clos also allows one to add , redefine and remove methods at runtime . the circle-ellipse problem is readily solved in clos , and most oop design patterns either disappear or are qualitatively simpler . in the design patterns in dynamic languages slides , peter norvig presents his findings that 16 out of 23 design patterns taken from various textbooks are either '' invisible or simpler '' in dylan or common lisp than in c++ . clos is not a prototype language : classes must be defined before objects can be instantiated as members of that class . metaobject protocol . outside of the ansi common lisp standard , there is a widely implemented extension to clos called the metaobject protocol ( mop ) . the mop defines a standard interface to the underpinnings of the clos implementation , treating classes , slot-descriptions , generic-functions and methods themselves as instances of metaclasses , and allows the definition of new metaclasses and the modification of all clos behavior . the flexibility of the clos mop prefigures aspect-oriented programming , which was later developed by some of the same engineers , such as gregor kiczales . the mop defines the behavior of the whole object system by a set of protocols . these are defined in terms of clos . thus it is possible to create new object-systems by extending or changing the provided clos functionality . the book the art of the metaobject protocol describes the use and implementation of the clos mop . the various common lisp implementations have slightly different support for the meta-object protocol . the closer closer project : closer to mop project aims to provide the missing features . influences from older lisp-based object systems . flavors ( and its successor new flavors ) was the object system on the mit lisp machine . large parts of the lisp machine operating systems and many applications for it use flavors or new flavors . flavors introduced multiple inheritance and mixins , among other features . flavors is mostly obsolete , though implementations for common lisp do exist . flavors was using the message passing paradigm . new flavors introduced generic functions . commonloops was the successor of loops ( from xerox interlisp-d ) . commonloops was implemented for common lisp . a portable implementation called portable commonloops ( pcl ) was the first implementation of clos . pcl is widely ported and still provides the base for the clos implementation of several common lisp implementations . pcl is implemented mostly in portable common lisp with only a few system dependent parts . clos in other programming languages . because of the power and expressivity of clos , as well as the historical availability of tinyclos ( a simplified portable clos implementation written by gregor kiczales for use with scheme ) , clos-like mop-based object systems have become the de facto norm in most lisp dialect implementations , as well as finding their way into some other languages ' oop facilities : cos , the c object system cos , the c object system dylan dynace , a ( largely ) clos implementation in c dynace object oriented extension to c eieio for emacs lisp . gauche , scheme with clos goops in gnu guile ilos in islisp meroon , an object system in scheme sagittarius , a scheme with clos scmobj , for scheme sos for mit scheme stklos , a scheme with clos swindle in racket coops in chicken scheme vclos for skill vclos , clos for skill tiny clos , developed by gregor kiczales . references . '' commonloops : merging lisp and object-oriented programming '' , by daniel g . bobrow , kenneth kahn , gregor kiczales , larry masinter , mark stefik , frank zdybel . 1986 , portland , oregon , united states . pages 17–29 of the conference on object-oriented programming systems languages and applications , issn 0362-1340 . '' a history and description of clos '' , by jim veitch . pages 107–158 of handbook of programming languages , volume iv : functional and logic programming languages , ed . peter h . salus . 1998 ( 1st edition ) , macmillan technical publishing ; . literature . sonya keene , object-oriented programming in common lisp : a programmer 's guide to clos , 1988 , addison-wesley . gregor kiczales , jim des rivieres , and daniel g . bobrow , the art of the metaobject protocol , 1991 , mit press . jo a . lawless and molly m . miller , understanding clos : the common lisp object system , 1991 , digital press , andreas paepcke , object-oriented programming : the clos perspective , 1993 , the mit press . the common lisp object system : an overview by richard p . gabriel and linda demichiel provides a good introduction to the motivation for defining classes by means of generic functions . fundamentals of clos by nick levine provides a step-by-step exposure to the implementation of oo concepts in clos , and how to utilize them . it is intended for anybody with a basic knowledge of lisp or scheme . common lisp hyperspec , chapter 7 : objects