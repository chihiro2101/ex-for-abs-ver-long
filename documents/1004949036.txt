Scene graph

scene graphs in graphics editing tools . in vector-based graphics editing , each leaf node in a scene graph represents some atomic unit of the document , usually a shape such as an ellipse or bezier path . although shapes themselves ( particularly paths ) can be decomposed further into nodes such as spline nodes , it is practical to think of the scene graph as composed of shapes rather than going to a lower level of representation . another useful and user-driven node concept is the layer . a layer acts like a transparent sheet upon which any number of shapes and shape groups can be placed . the document then becomes a set of layers , any of which can be conveniently made invisible , dimmed , or locked ( made read-only ) . some applications place all layers in a linear list , while others support layers within layers to any desired depth . internally , there may be no real structural difference between layers and groups at all , since they are both just nodes of a scene graph . if differences are needed , a common type declaration in c++ would be to make a generic node class , and then derive layers and groups as subclasses . a visibility member , for example , would be a feature of a layer , but not necessarily of a group . scene graphs in games and 3d applications . scene graphs are useful for modern games using 3d graphics and increasingly large worlds or levels . in such applications , nodes in a scene graph ( generally ) represent entities or objects in the scene . for instance , a game might define a logical relationship between a knight and a horse so that the knight is considered an extension to the horse . the scene graph would have a 'horse ' node with a 'knight ' node attached to it . the scene graph may also describe the spatial , as well as the logical , relationship of the various entities : the knight moves through 3d space as the horse moves . in these large applications , memory requirements are major considerations when designing a scene graph . for this reason , many large scene graph systems use geometry instancing to reduce memory costs and increase speed . in our example above , each knight is a separate scene node , but the graphical representation of the knight ( made up of a 3d mesh , textures , materials and shaders ) is instanced . this means that only a single copy of the data is kept , which is then referenced by any 'knight ' nodes in the scene graph . this allows a reduced memory budget and increased speed , since when a new knight node is created , the appearance data needs not be duplicated . scene graph implementation . the simplest form of scene graph uses an array or linked list data structure , and displaying its shapes is simply a matter of linearly iterating the nodes one by one . other common operations , such as checking to see point location are also done via linear searches . for small scene graphs , this tends to suffice . scene graph operations and dispatch . applying an operation on a scene graph requires some way of dispatching an operation based on a node 's type . for example , in a render operation , a transformation group node would accumulate its transformation by matrix multiplication , vector displacement , quaternions or euler angles . after which a leaf node sends the object off for rendering to the renderer . some implementations might render the object directly , which invokes the underlying rendering api , such as directx or opengl . but since the underlying implementation of the rendering api usually lacks portability , one might separate the scene graph and rendering systems instead . in order to accomplish this type of dispatching , several different approaches can be taken . in object-oriented languages such as c++ , this can easily be achieved by virtual functions , where each represents an operation that can be performed on a node . virtual functions are simple to write , but it is usually impossible to add new operations to nodes without access to the source code . alternatively , the visitor pattern can be used . this has a similar disadvantage in that it is similarly difficult to add new node types . other techniques involve the use of rtti ( run-time type information ) . the operation can be realised as a class that is passed to the current node ; it then queries the node 's type using rtti and looks up the correct operation in an array of callbacks or functors . this requires that the map of types to callbacks or functors be initialized at runtime , but offers more flexibility , speed and extensibility . variations on these techniques exist , and new methods can offer added benefits . one alternative is scene graph rebuilding , where the scene graph is rebuilt for each of the operations performed . this , however , can be very slow , but produces a highly optimised scene graph . it demonstrates that a good scene graph implementation depends heavily on the application in which it is used . traversals . traversals are the key to the power of applying operations to scene graphs . a traversal generally consists of starting at some arbitrary node ( often the root of the scene graph ) , applying the operation ( s ) ( often the updating and rendering operations are applied one after the other ) , and recursively moving down the scene graph ( tree ) to the child nodes , until a leaf node is reached . at this point , many scene graph engines then traverse back up the tree , applying a similar operation . for example , consider a render operation that takes transformations into account : while recursively traversing down the scene graph hierarchy , a pre-render operation is called . if the node is a transformation node , it adds its own transformation to the current transformation matrix . once the operation finishes traversing all the children of a node , it calls the node 's post-render operation so that the transformation node can undo the transformation . this approach drastically reduces the necessary amount of matrix multiplication . some scene graph operations are actually more efficient when nodes are traversed in a different order – this is where some systems implement scene graph rebuilding to reorder the scene graph into an easier-to-parse format or tree . for example , in 2d cases , scene graphs typically render themselves by starting at the tree 's root node and then recursively draw the child nodes . the tree 's leaves represent the most foreground objects . since drawing proceeds from back to front with closer objects simply overwriting farther ones , the process is known as employing the painter 's algorithm . in 3d systems , which often employ depth buffers , it is more efficient to draw the closest objects first , since farther objects often need only be depth-tested instead of actually rendered , because they are occluded by nearer objects . scene graphs and bounding volume hierarchies ( bvhs ) . bounding volume hierarchy ( bvhs ) are useful for numerous tasks – including efficient culling and speeding up collision detection between objects . a bvh is a spatial structure , but does n't have to partition the geometry ( see spatial partitioning below ) . a bvh is a tree of bounding volumes ( often spheres , axis-aligned bounding boxes or oriented bounding boxes ) . at the bottom of the hierarchy , the size of the volume is just large enough to encompass a single object tightly ( or possibly even some smaller fraction of an object in high resolution bvhs ) . as one ascends the hierarchy , each node has its own volume that tightly encompasses all the volumes beneath it . at the root of the tree is a volume that encompasses all the volumes in the tree ( the whole scene ) . bvhs are useful for speeding up collision detection between objects . if an object 's bounding volume does not intersect a volume higher in the tree , it can not intersect any object below that node ( so they are all rejected very quickly ) . there are some similarities between bvhs and scene graphs . a scene graph can easily be adapted to include/become a bvh – if each node has a volume associated or there is a purpose-built '' bound node '' added in at convenient location in the hierarchy . this may not be the typical view of a scene graph , but there are benefits to including a bvh in a scene graph . scene graphs and spatial partitioning . an effective way of combining space partitioning and scene graphs is by creating a scene leaf node that contains the spatial partitioning data . this can increase computational efficiency of rendering . spatial data is usually static and generally contains non-moving scene data in some partitioned form . some systems may have the systems and their rendering separately . this is fine and there are no real advantages to either method . in particular , it is bad to have the scene graph contained within the spatial partitioning system , as the scene graph is better thought of as the grander system to the spatial partitioning . very large drawings , or scene graphs that are generated solely at runtime ( as happens in ray tracing rendering programs ) , require defining of group nodes in a more automated fashion . a raytracer , for example , will take a scene description of a 3d model and build an internal representation that breaks up its individual parts into bounding boxes ( also called bounding slabs ) . these boxes are grouped hierarchically so that ray intersection tests ( as part of visibility determination ) can be efficiently computed . a group box that does not intersect an eye ray , for example , can entirely skip testing any of its members . a similar efficiency holds in 2d applications as well . if the user has magnified a document so that only part of it is visible on his computer screen , and then scrolls in it , it is useful to use a bounding box ( or in this case , a bounding rectangle scheme ) to quickly determine which scene graph elements are visible and thus actually need to be drawn . depending on the particulars of the application 's drawing performance , a large part of the scene graph 's design can be impacted by rendering efficiency considerations . in 3d video games such as quake , binary space partitioning ( bsp ) trees are heavily favored to minimize visibility tests . bsp trees , however , take a very long time to compute from design scene graphs , and must be recomputed if the design scene graph changes , so the levels tend to remain static , and dynamic characters are n't generally considered in the spatial partitioning scheme . scene graphs for dense regular objects such as heightfields and polygon meshes tend to employ quadtrees and octrees , which are specialized variants of a 3d bounding box hierarchy . since a heightfield occupies a box volume itself , recursively subdividing this box into eight subboxes ( hence the 'oct ' in octree ) until individual heightfield elements are reached is efficient and natural . a quadtree is simply a 2d octree . standards . phigs . phigs was the first commercial scene graph specification , and became an ansi standard in 1988 . disparate implementations were provided by unix hardware vendors . the hoops 3d graphics system appears to have been the first commercial scene graph library provided by a single software vendor . it was designed to run on disparate lower-level 2d and 3d interfaces , with the first major production version ( v3.0 ) completed in 1991 . sgi . silicon graphics ( sgi ) released opengl performer or more commonly called performer in 1991 which was the primary scenegraph system for most sgi products into the future . iris inventor 1.0 ( 1992 ) was released by sgi , which was a high level scene graph built on top of performer . it was followed up with open inventor in 1994 , another iteration of the high level scene graph built on top of newer releases of performer . more 3d scene graph libraries can be found in : category:3d scenegraph apis . x3d . x3d is a royalty-free open standards file format and run-time architecture to represent and communicate 3d scenes and objects using xml . it is an iso-ratified standard that provides a system for the storage , retrieval and playback of real-time graphics content embedded in applications , all within an open architecture to support a wide array of domains and user scenarios . see also . graph ( data structure ) graph theory space partitioning tree ( data structure ) . references . books . leler , wm and merry , jim ( 1996 ) 3d with hoops , addison-wesley wernecke , josie ( 1994 ) the inventor mentor : programming object-oriented 3d graphics with open inventor , addison-wesley , ( release 2 ) . articles . bar-zeev , avi . '' scenegraphs : past , present , and future '' carey , rikk and bell , gavin ( 1997 ) . '' the annotated vrml 97 reference manual '' helman , jim ; rohlf , john ( 1994 ) . '' iris performer : a high performance multiprocessing toolkit for real-time 3d graphics '' pextimes – '' unofficially , the phigs extension to x . officially , pex was not an acronym . '' strauss , paul ( 1993 ) . '' iris inventor , a 3d graphics toolkit '' . external links . java3d aviatrix3d lg3d opensg irisperformer openscenegraph visualization library