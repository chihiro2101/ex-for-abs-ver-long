One-instruction set computer

machine architecture . in a turing completeness , each memory location can store an arbitrary integer , anddepending on the modelthere may be arbitrarily many locations . the instructions themselves reside in memory as a sequence of such integers . there exists a class of universal computers with a single instruction based on bit manipulation such as bit copying or bit inversion . since their memory model is finite , as is the memory structure used in real computers , those bit manipulation machines are equivalent to real computers rather than to turing machines . oleg mazonka , '' bit copying : the ultimate computational simplicity '' , complex systems journal 2011 , vol 19 , n3 , pp . 263–285 currently known oiscs can be roughly separated into three broad categories : bit-manipulating machines transport triggered architecture machines arithmetic-based turing-complete machines . bit-manipulating machines . bit-manipulating machines are the simplest class . bitbitjump . a bit copying machine , called bitbitjump , copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction . this process turns out to be capable of universal computation ( i.e . being able to execute any algorithm and to interpret any other universal machine ) because copying bits can conditionally modify the code that will be subsequently executed . toga computer . another machine , called the toga computer , inverts a bit and passes the execution conditionally depending on the result of inversion . the unique instruction is toga ( a , b ) which stands for toggle a and branch to b if the result of the toggle operation is true . multi-bit copying machine . similar to bitbitjump , a multi-bit copying machine copies several bits at the same time . the problem of turing completeness is solved in this case by keeping predefined jump tables in the memory . transport triggered architecture . transport triggered architecture ( tta ) is a design in which computation is a side effect of data transport . usually , some memory registers ( triggering ports ) within common address space perform an assigned operation when the instruction references them . for example , in an oisc using a single memory-to-memory copy instruction , this is done by triggering ports that perform arithmetic and instruction pointer jumps when written to . arithmetic-based turing-complete machines . arithmetic-based turing-complete machines use an arithmetic operation and a conditional jump . like the two previous universal computers , this class is also turing-complete . the instruction operates on integers which may also be addresses in memory . currently there are several known oiscs of this class , based on different arithmetic operations : addition ( addleq , add and branch if l ess than or eq ual to zero ) decrement ( djn , d ecrement and branch ( j ump ) if n onzero ) increment ( p1eq , p lus 1 and branch if eq ual to another value ) subtraction ( subleq , sub tract and branch if l ess than or eq ual to zero ) subtraction when possible ( arithmetic machine ) . instruction types . common choices for the single instruction are : subtract and branch if less than or equal to zero subtract and branch if negative arithmetic machine reverse subtract and skip if borrow move ( used as part of a transport triggered architecture ) subtract and branch if non zero ( sbnz a , b , c , destination ) cryptoleq ( heterogeneous encrypted and unencrypted computation ) only one of these instructions is used in a given implementation . hence , there is no need for an opcode to identify which instruction to execute ; the choice of instruction is inherent in the design of the machine , and an oisc is typically named after the instruction it uses ( e.g . , an sbn oisc , the subleq language , etc . ) . each of the above instructions can be used to construct a turing-complete oisc . this article presents only subtraction-based instructions among those that are not transport triggered . however , it is possible to construct turing complete machines using an instruction based on other arithmetic operations , e.g . , addition . for example , one variation known as dln ( decrement and jump if not zero ) has only two operands and uses decrement as the base operation . for more information see subleq derivative languages . subtract and branch if not equal to zero . the sbnz a , b , c , d instruction ( '' subtract and branch if not equal to zero '' ) subtracts the contents at address a from the contents at address b , stores the result at address c , and then , if the result is not 0 , transfers control to address d ( if the result is equal to zero , execution proceeds to the next instruction in sequence ) . . subtract and branch if less than or equal to zero . the instruction ( '' subtract and branch if less than or equal to zero '' ) subtracts the contents at address from the contents at address , stores the result at address , and then , if the result is not positive , transfers control to address ( if the result is positive , execution proceeds to the next instruction in sequence ) . pseudocode : subleq a , b , c ; memb memb - mema ; if ( memb ≤ 0 ) goto c conditional branching can be suppressed by setting the third operand equal to the address of the next instruction in sequence . if the third operand is not written , this suppression is implied . a variant is also possible with two operands and an internal accumulator , where the accumulator is subtracted from the memory location specified by the first operand . the result is stored in both the accumulator and the memory location , and the second operand specifies the branch address : subleq2 a , b ; mema mema - accum ; accum mema ; if ( mema ≤ 0 ) goto b although this uses only two ( instead of three ) operands per instruction , correspondingly more instructions are then needed to effect various logical operations . synthesized instructions . it is possible to synthesize many types of higher-order instructions using only the instruction . unconditional branch : ; : subleq z , z , c addition can be performed by repeated subtraction , with no conditional branching ; e.g . , the following instructions result in the content at location being added to the content at location : ; : subleq a , z subleq z , b subleq z , z the first instruction subtracts the content at location from the content at location ( which is 0 ) and stores the result ( which is the negative of the content at in location . the second instruction subtracts this result from , storing in this difference ( which is now the sum of the contents originally at and ; the third instruction restores the value 0 to . a copy instruction can be implemented similarly ; e.g . , the following instructions result in the content at location getting replaced by the content at location , again assuming the content at location is maintained as 0 : ; : subleq b , b subleq a , z subleq z , b subleq z , z any desired arithmetic test can be built . for example , a branch-if-zero condition can be assembled from the following instructions : ; : subleq b , z , l1 subleq z , z , out l1 : subleq z , z subleq z , b , c out : . subleq2 can also be used to synthesize higher-order instructions , although it generally requires more operations for a given task . for example , no fewer than 10 subleq2 instructions are required to flip all the bits in a given byte : ; : subleq2 tmp ; tmp 0 ( tmp temporary register ) subleq2 tmp subleq2 minus_one ; acc -1 subleq2 a ; a ' a + 1 subleq2 z ; z - a - 1 subleq2 tmp ; tmp a + 1 subleq2 a ; a ' 0 subleq2 tmp ; load tmp into acc subleq2 a ; a ' - a - 1 ( ~a ) subleq2 z ; set z back to 0 . emulation . the following program ( written in pseudocode ) emulates the execution of a -based oisc : int memory , program_counter , a , b , c program_counter 0 while ( program_counter > 0 ) : a memoryprogram_counter b memoryprogram_counter+1 c memoryprogram_counter+2 if ( a 0 ) : program_counter + 3 else : program_counter c this program assumes that is indexed by nonnegative integers . consequently , for a instruction , , , the program interprets , , or an executed branch to as a halting condition . similar interpreters written in a -based language ( i.e . , self-interpreters , which may use self-modifying code as allowed by the nature of the instruction ) can be found in the external links below . compilation . there is a compiler called higher subleq written by oleg mazonka that compiles a simplified c program into code . oleg mazonka a simple multi-processor computer based on subleq . subtract and branch if negative . the instruction ( '' subtract and branch if negative '' ) , also called , is defined similarly to : subneg a , b , c ; memb memb - mema ; if ( memb conditional branching can be suppressed by setting the third operand equal to the address of the next instruction in sequence . if the third operand is not written , this suppression is implied . synthesized instructions . it is possible to synthesize many types of higher-order instructions using only the instruction . for simplicity , only one synthesized instruction is shown here to illustrate the difference between and . unconditional branch : ; : subneg pos , z , c . c : subneg z , z where and are locations previously set to contain 0 and a positive integer , respectively ; unconditional branching is assured only if initially contains 0 ( or a value less than the integer stored in . a follow-up instruction is required to clear after the branching , assuming that the content of must be maintained as 0 . subneg4 . a variant is also possible with four operands – subneg4 . the reversal of minuend and subtrahend eases implementation in hardware . the non-destructive result simplifies the synthetic instructions . subneg4 s , m , r , j ; subtrahend , minuend , result and jump addresses ; memr memm - mems ; if ( memr . arithmetic machine . in an attempt to make turing machine more intuitive , z . a . melzac consider the task of computing with positive numbers . the machine has an infinite abacus , an infinite number of counters ( pebbles , tally sticks ) initially at a special location s . the machine is able to do one operation : take from location x as many counters as there are in location y and transfer them to location z and proceed to next instruction . if this operation is not possible because there is not enough counters in y , then leave the abacus as it is and proceed to instruction t . this essentially a subneg where the test is done before rather than after the subtraction , in order to keep all numbers positive and mimic a human operator computing on a real world abacus . pseudocode : command x , y , z , t ; if ( memy after giving a few programs : multiplication , gcd , computing the n-th prime number , representation in base b of an arbitrary number , sorting in order of magnitude , melzac shows explicitly how to simulate an arbitrary turing machine on his arithmetic machine . he mentions that it can easily be shown using the elements of recursive functions that every number calculable on the arithmetic machine is computable . a proof of which was given by lambek on an equivalent two instruction machine : x+ ( increment x ) and x− else t ( decrement x if it not empty , else jump to t ) . reverse subtract and skip if borrow . in a reverse subtract and skip if borrow ( rssb ) instruction , the accumulator is subtracted from the memory location and the next instruction is skipped if there was a borrow ( memory location was smaller than the accumulator ) . the result is stored in both the accumulator and the memory location . the program counter is mapped to memory location 0 . the accumulator is mapped to memory location 1 . . example . to set x to the value of y minus z : first , move z to the destination location x . rssb temp three instructions required to clear acc , temp see note 1 rssb temp rssb temp rssb x two instructions clear acc , x , since acc is already clear rssb x rssb y load y into acc : no borrow rssb temp store -y into acc , temp : always borrow and skip rssb temp skipped rssb x store y into x , acc second , perform the operation . rssb temp three instructions required to clear acc , temp rssb temp rssb temp rssb z load z rssb x x y - z see note 2 note 1 if the value stored at '' temp '' is initially a negative value and the instruction that executed right before the first '' rssb temp '' in this routine borrowed , then four '' rssb temp '' instructions will be required for the routine to work . note 2 if the value stored at '' z '' is initially a negative value then the final '' rssb x '' will be skipped and thus the routine will not work . transport triggered architecture . a transport triggered architecture uses only the move instruction , hence it was originally called a '' move machine '' . this instruction moves the contents of one memory location to another memory location combining with the current content of the new location : move a to b ; memb : mema ( + , - , , / , . ) memb sometimes written as : a - > b ; memb : mema ( + , - , , / , . ) memb the operation performed is defined by the destination memory cell . some cells are specialized in addition , some other in multiplication , etc . so memory cells are not simple store but coupled with an arithmetic logic unit ( alu ) setup to perform only one sort of operation with the current value of the cell . some of the cells are control flow instructions to alter the program execution with jumps , conditional execution , subroutines , if-then-else , for-loop , etc . a commercial transport triggered architecture microcontroller has been produced called maxq , which hides the apparent inconvenience of an oisc by using a '' transfer map '' that represents all possible destinations for the move instructions . . cryptoleq . cryptoleq is a language consisting of one eponymous instruction , is capable of performing general-purpose computation on encrypted programs and is a close relative to subleq . cryptoleq works on continuous cells of memory using direct and indirect addressing , and performs two operations and on three values a , b , and c : cryptoleq a , b , c b o 1 ( a , b ) ; ip c , if o 2 b ≤ 0 ip ip + 3 , otherwise where a , b and c are addressed by the instruction pointer , ip , with the value of ip addressing a , ip + 1 point to b and ip + 2 to c . in cryptoleq operations and are defined as follows : : \begin equals . the multiplication algorithm is based on addition and subtraction , uses the function g and does not have conditional jumps nor branches . cryptoleq encryption is based on paillier cryptosystem .