Semaphore (programming)

library analogy . suppose a library has 10 identical study rooms , to be used by one student at a time . students must request a room from the front desk if they wish to use a study room . if no rooms are free , students wait at the desk until someone relinquishes a room . when a student has finished using a room , the student must return to the desk and indicate that one room has become free . in the simplest implementation , the clerk at the front desk knows only the number of free rooms available , which they only know correctly if all of the students actually use their room while they 've signed up for them and return them when they 're done . when a student requests a room , the clerk decreases this number . when a student releases a room , the clerk increases this number . the room can be used for as long as desired , and so it is not possible to book rooms ahead of time . in this scenario the front desk count-holder represents a counting semaphore , the rooms are the resource , and the students represent processes/threads . the value of the semaphore in this scenario is initially 10 , with all rooms empty . when a student requests a room , they are granted access , and the value of the semaphore is changed to 9 . after the next student comes , it drops to 8 , then 7 and so on . if someone requests a room and the current value of the semaphore is 0 , the little book of semaphores allen b . downey they are forced to wait until a room is freed ( when the count is increased from 0 ) . if one of the rooms was released , but there are several students waiting , then any method can be used to select the one who will occupy the room ( like fifo or flipping a coin ) . and of course , a student needs to inform the clerk about releasing their room only after really leaving it , otherwise , there can be an awkward situation when such student is in the process of leaving the room ( they are packing their textbooks , etc . ) and another student enters the room before they leave it . important observations . when used to control access to a pool of resources , a semaphore tracks only how many resources are free ; it does not keep track of which of the resources are free . some other mechanism ( possibly involving more semaphores ) may be required to select a particular free resource . the paradigm is especially powerful because the semaphore count may serve as a useful trigger for a number of different actions . the librarian above may turn the lights off in the study hall when there are no students remaining , or may place a sign that says the rooms are very busy when most of the rooms are occupied . the success of the protocol requires applications to follow it correctly . fairness and safety are likely to be compromised ( which practically means a program may behave slowly , act erratically , hang or crash ) if even a single process acts incorrectly . this includes : requesting a resource and forgetting to release it ; releasing a resource that was never requested ; holding a resource for a long time without needing it ; using a resource without requesting it first ( or after releasing it ) . even if all processes follow these rules , multi-resource deadlock may still occur when there are different resources managed by different semaphores and when processes need to use more than one resource at a time , as illustrated by the dining philosophers problem . semantics and implementation . counting semaphores are equipped with two operations , historically denoted as p and v ( see for alternative names ) . operation v increments the semaphore s , and operation p decrements it . the value of the semaphore s is the number of units of the resource that are currently available . the p operation wastes time or sleeps until a resource protected by the semaphore becomes available , at which time the resource is immediately claimed . the v operation is the inverse : it makes a resource available again after the process has finished using it . one important property of semaphore s is that its value can not be changed except by using the v and p operations . a simple way to understand ( p ) and ( v ) operations is : : decrements the value of semaphore variable by 1 . if the new value of the semaphore variable is negative , the process executing is blocked ( i.e . , added to the semaphore 's queue ) . otherwise , the process continues execution , having used a unit of the resource . : increments the value of semaphore variable by 1 . after the increment , if the pre-increment value was negative ( meaning there are processes waiting for a resource ) , it transfers a blocked process from the semaphore 's waiting queue to the ready queue . many operating systems provide efficient semaphore primitives that unblock a waiting process when the semaphore is incremented . this means that processes do not waste time checking the semaphore value unnecessarily . the counting semaphore concept can be extended with the ability to claim or return more than one '' unit '' from the semaphore , a technique implemented in unix . the modified v and p operations are as follows , using square brackets to indicate atomic operations , i.e . , operations which appear indivisible from the perspective of other processes : function v ( semaphore s , integer i ) : s ← s + i function p ( semaphore s , integer i ) : repeat : if s ≥ i : s ← s − i break however , the remainder of this section refers to semaphores with unary v and p operations , unless otherwise specified . to avoid starvation , a semaphore has an associated queue of processes ( usually with fifo semantics ) . if a process performs a p operation on a semaphore that has the value zero , the process is added to the semaphore 's queue and its execution is suspended . when another process increments the semaphore by performing a v operation , and there are processes on the queue , one of them is removed from the queue and resumes execution . when processes have different priorities the queue may be ordered by priority , so that the highest priority process is taken from the queue first . if the implementation does not ensure atomicity of the increment , decrement and comparison operations , then there is a risk of increments or decrements being forgotten , or of the semaphore value becoming negative . atomicity may be achieved by using a machine instruction that is able to read-modify-write the semaphore in a single operation . in the absence of such a hardware instruction , an atomic operation may be synthesized through the use of a mutual exclusion software solutions . on uniprocessor systems , atomic operations can be ensured by temporarily suspending preemption or disabling hardware interrupts . this approach does not work on multiprocessor systems where it is possible for two programs sharing a semaphore to run on different processors at the same time . to solve this problem in a multiprocessor system a locking variable can be used to control access to the semaphore . the locking variable is manipulated using a test-and-set command . examples . trivial example . consider a variable a and a boolean variable s . a is only accessed when s is marked true . thus , s is a semaphore for a . one can imagine a stoplight signal ( s ) just before a train station ( a ) . in this case , if the signal is green , then one can enter the train station . if it is yellow or red ( or any other color ) , the train station can not be accessed . login queue . consider a system that can only support ten users ( s 10 ) . whenever a user logs in , p is called , decrementing the semaphore s by 1 . whenever a user logs out , v is called , incrementing s by 1 representing a login slot that has become available . when s is 0 , any users wishing to log in must wait until and the login request is enqueued onto a fifo queue ; mutual exclusion is used to ensure that requests are enqueued in order . whenever s becomes greater than 0 ( login slots available ) , a login request is dequeued , and the user owning the request is allowed to log in . producer–consumer problem . in the producer–consumer problem , one process ( the producer ) generates data items and another process ( the consumer ) receives and uses them . they communicate using a queue of maximum size n and are subject to the following conditions : the consumer must wait for the producer to produce something if the queue is empty ; the producer must wait for the consumer to consume something if the queue is full . the semaphore solution to the producer–consumer problem tracks the state of the queue with two semaphores : emptycount , the number of empty places in the queue , and fullcount , the number of elements in the queue . to maintain integrity , emptycount may be lower ( but never higher ) than the actual number of empty places in the queue , and fullcount may be lower ( but never higher ) than the actual number of items in the queue . empty places and items represent two kinds of resources , empty boxes and full boxes , and the semaphores emptycount and fullcount maintain control over these resources . the binary semaphore usequeue ensures that the integrity of the state of the queue itself is not compromised , for example by two producers attempting to add items to an empty queue simultaneously , thereby corrupting its internal state . alternatively a mutex could be used in place of the binary semaphore . the emptycount is initially n , fullcount is initially 0 , and usequeue is initially 1 . the producer does the following repeatedly : produce : p ( emptycount ) p ( usequeue ) putitemintoqueue ( item ) v ( usequeue ) v ( fullcount ) the consumer does the following repeatedly consume : p ( fullcount ) p ( usequeue ) item ← getitemfromqueue ( ) v ( usequeue ) v ( emptycount ) below is a substantive example : a single consumer enters its critical section . since fullcount is 0 , the consumer blocks . several producers enter the producer critical section . no more than n producers may enter their critical section due to emptycount constraining their entry . the producers , one at a time , gain access to the queue through usequeue and deposit items in the queue . once the first producer exits its critical section , fullcount is incremented , allowing one consumer to enter its critical section . note that emptycount may be much lower than the actual number of empty places in the queue , for example in the case where many producers have decremented it but are waiting their turn on usequeue before filling empty places . note that emptycount + fullcount ≤ n always holds , with equality if and only if no producers or consumers are executing their critical sections . operation names . the canonical names v and p come from the initials of dutch words . v is generally explained as verhogen ( '' increase '' ) . several explanations have been offered for p , including proberen ( '' to test '' or '' to try '' ) , passeren ( '' pass '' ) , and pakken ( '' grab '' ) . dijkstra 's earliest paper on the subject gives passering ( '' passing '' ) as the meaning for p , and vrijgave ( '' release '' ) as the meaning for v . it also mentions that the terminology is taken from that used in railroad signals . dijkstra subsequently wrote that he intended p to stand for prolaag , short for probeer te verlagen , literally '' try to reduce '' , or to parallel the terms used in the other case , '' try to decrease '' . ( in dutch ) dijkstra 's own translation reads '' try-and-decrease '' , although that phrase might be confusing for those unaware of the colloquial '' try-and . '' ( patch 1/19 ) mutex : introduce simple mutex implementation linux kernel mailing list , 19 december 2005 in algol 68 , the linux kernel , linux kernel hacking howto linuxgrill.com and in some english textbooks , the v and p operations are called , respectively , up and down . in software engineering practice , they are often called signal and wait , release and acquire ( which the standard java library uses ) , or post and pend . some texts call them vacate and procure to match the original dutch initials . semaphores vs . mutexes . a mutex is a locking mechanism that sometimes uses the same basic implementation as the binary semaphore . the differences between them are in how they are used . while a binary semaphore may be colloquially referred to as a mutex , a true mutex has a more specific use-case and definition , in that only the task that locked the mutex is supposed to unlock it . this constraint aims to handle some potential problems of using semaphores : priority inversion : if the mutex knows who locked it and is supposed to unlock it , it is possible to promote the priority of that task whenever a higher-priority task starts waiting on the mutex . premature task termination : mutexes may also provide deletion safety , where the task holding the mutex can not be accidentally deleted . termination deadlock : if a mutex-holding task terminates for any reason , the os can release the mutex and signal waiting tasks of this condition . recursion deadlock : a task is allowed to lock a reentrant mutex multiple times as it unlocks it an equal number of times . accidental release : an error is raised on the release of the mutex if the releasing task is not its owner . see also . cigarette smokers problem dining philosophers problem readers-writers problem sleeping barber problem monitor spurious wakeup . references . external links . introductions . hilsheimer , volker ( 2004 ) . '' implementing a read/write mutex '' ( web page ) . qt quarterly , issue 11 - q3 2004