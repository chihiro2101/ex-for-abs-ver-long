Iterator

description . internal iterators . internal iterators are higher order functions ( often taking anonymous functions ) such as map , reduce etc . , implementing the traversal across a container , applying the given function to every element in turn . external iterators and the iterator pattern . an external iterator may be thought of as a type of pointer that has two primary operations : referencing one particular element in the object collection ( called element access ) , and modifying itself so it points to the next element ( called element traversal ) . there must also be a way to create an iterator so it points to some first element as well as some way to determine when the iterator has exhausted all of the elements in the container . depending on the language and intended use , iterators may also provide additional operations or exhibit different behaviors . the primary purpose of an iterator is to allow a user to process every element of a container while isolating the user from the internal structure of the container . this allows the container to store elements in any manner it wishes while allowing the user to treat it as if it were a simple sequence or list . an iterator class is usually designed in tight coordination with the corresponding container class . usually , the container provides the methods for creating iterators . a loop counter is sometimes also referred to as a loop iterator . a loop counter , however , only provides the traversal functionality and not the element access functionality . generators . one way of implementing iterators is to use a restricted form of coroutine , known as a generator . by contrast with a subroutine , a generator coroutine can yield values to its caller multiple times , instead of returning just once . most iterators are naturally expressible as generators , but because generators preserve their local state between invocations , they 're particularly well-suited for complicated , stateful iterators , such as tree traversal . there are subtle differences and distinctions in the use of the terms '' generator '' and '' iterator '' , which vary between authors and languages . in python , a generator is an iterator constructor : a function that returns an iterator . an example of a python generator returning an iterator for the fibonacci numbers using python 's yield statement follows : def fibonacci ( limit ) : a , b 0 , 1 for _ in range ( limit ) : yield a a , b b , a + b for number in fibonacci ( 100 ) : the generator constructs an iterator print ( number ) . implicit iterators . some object-oriented languages such as c , c++ ( later versions ) , delphi ( later versions ) , go , java ( later versions ) , lua , perl , python , ruby provide an intrinsic way of iterating through the elements of a container object without the introduction of an explicit iterator object . an actual iterator object may exist in reality , but if it does it is not exposed within the source code of the language . implicit iterators are often manifested by a '' foreach '' statement ( or equivalent ) , such as in the following python example : for value in iterable : print ( value ) in python , an iterable is an object which can be converted to an iterator , which is then iterated through during the for loop ; this is done implicitly . or other times they may be created by the collection object itself , as in this ruby example : iterable.each do value puts value end this iteration style is sometimes called '' internal iteration '' because its code fully executes within the context of the iterable object ( that controls all aspects of iteration ) , and the programmer only provides the operation to execute at each step ( using an anonymous function ) . languages that support list comprehensions or similar constructs may also make use of implicit iterators during the construction of the result list , as in python : names person.name for person in roster if person.male sometimes the implicit hidden nature is only partial . the c++ language has a few function templates for implicit iteration , such as for_each ( ) . these functions still require explicit iterator objects as their initial input , but the subsequent iteration does not expose an iterator object to the user . streams . iterators are a useful abstraction of input streams â€“ they provide a potentially infinite iterable ( but not necessarily indexable ) object . several languages , such as perl and python , implement streams as iterators . in python , iterators are objects representing streams of data . alternative implementations of stream include data-driven languages , such as awk and sed . contrasting with indexing . in procedural languages it is common to use the subscript operator and a loop counter to loop through all the elements in a sequence such as an array . although indexing may also be used with some object-oriented containers , the use of iterators may have some advantages : counting loops are not suitable to all data structures , in particular to data structures with no or slow random access , like lists or trees . iterators can provide a consistent way to iterate on data structures of all kinds , and therefore make the code more readable , reusable , and less sensitive to a change in the data structure . an iterator can enforce additional restrictions on access , such as ensuring that elements can not be skipped or that a previously visited element can not be accessed a second time . an iterator may allow the container object to be modified without invalidating the iterator . for instance , once an iterator has advanced beyond the first element it may be possible to insert additional elements into the beginning of the container with predictable results . with indexing this is problematic since the index numbers must change . the ability of a container to be modified while iterating through its elements has become necessary in modern object-oriented programming , where the interrelationships between objects and the effects of operations may not be obvious . by using an iterator one is isolated from these sorts of consequences . this assertion must however be taken with a grain of salt , because more often than not , for efficiency reasons , the iterator implementation is so tightly bound to the container that it does preclude modification of the underlying container without invalidating itself . for containers that may move around their data in memory , the only way to not invalidate the iterator is , for the container , to somehow keep track of all the currently alive iterators and update them on the fly . since the number of iterators at a given time may be arbitrarily large in comparison to the size of the tied container , updating them all will drastically impair the complexity guarantee on the container 's operations . an alternative way to keep the number of updates bound relatively to the container size would be to use a kind of handle mechanism , that is a collection of indirect pointers to the container 's elements that must be updated with the container , and let the iterators point to these handles instead of directly to the data elements . but this approach will negatively impact the iterator performance , since it must effectuate a double pointer following to access the actual data element . this is usually not desirable , because many algorithms using the iterators invoke the iterators data access operation more often than the advance method . it is therefore especially important to have iterators with very efficient data access . all in all , this is always a trade-off between security ( iterators remain always valid ) and efficiency . most of the time , the added security is not worth the efficiency price to pay for it . using an alternative container ( for example a singly linked list instead of a vector ) would be a better choice ( globally more efficient ) if the stability of the iterators is needed . classifying iterators . . iterator categories . iterators can be categorised according to their functionality . here is a ( non-exhaustive ) list of iterator categories : . see also . iteratee , in which , instead of the developer calling the iterator repeatedly to get new values , the iteratee is called repeatedly to process new chunks of data - an example of inversion of control . design pattern iteration iterator pattern range visitor pattern pointer ( computer programming ) . references . external links . java 's iterator , iterable and listiterator explained . net interface article '' understanding and using iterators '' by joshua gatcomb article '' a technique for generic iteration and its optimization '' ( 217 kb ) by stephen m . watt iterators boost c++ iterator library java interface php : object iteration stl iterators what are iterators ? - reference description