Program analysis

static program analysis . in the context of program correctness , static analysis can discover vulnerabilities during the development phase of the program . jovanovic , n . , kruegel , c . , & kirda , e . ( 2006 , may ) . pixy : a static analysis tool for detecting web application vulnerabilities . in security and privacy , 2006 ieee symposium on ( pp . 6-pp ) . ieee . these vulnerabilities are easier to correct than the ones found during the testing phase since static analysis leads to the root of the vulnerability . due to many forms of static analysis being computationally undecidable , the mechanisms for doing it will not always terminate with the right answer either because they sometimes return a false negative ( '' no problems found '' when the code does in fact have problems ) or a false positive , or because they never return the wrong answer but sometimes never terminate . despite their limitations , the first type of mechanism might reduce the number of vulnerabilities , while the second can sometimes give strong assurance of the lack of a certain class of vulnerabilities . incorrect optimizations are highly undesirable . so , in the context of program optimization , there are two main strategies to handle computationally undecidable analysis : an optimizer that is expected to complete in a relatively short amount of time , such as the optimizer in an optimizing compiler , may use a truncated version of an analysis that is guaranteed to complete in a finite amount of time , and guaranteed to only find correct optimizations . a third-party optimization tool may be implemented in such a way as to never produce an incorrect optimization , but also so that it can , in some situations , continue running indefinitely until it finds one ( which may never happen ) . in this case , the developer using the tool would have to stop the tool and avoid running the tool on that piece of code again ( or possibly modify the code to avoid tripping up the tool ) . however , there is also a third strategy that is sometimes applicable for languages that are not completely specified , such as c . an optimizing compiler is at liberty to generate code that does anything at runtime even crashes if it encounters source code whose semantics are unspecified by the language standard in use . control-flow . the purpose of control-flow analysis is to obtain information about which functions can be called at various points during the execution of a program . the collected information is represented by a control flow graph ( cfg ) where the nodes are instructions of the program and the edges represent the flow of control . by identifying code blocks and loops cfg becomes a starting point for compiler made optimizations . data-flow analysis . data-flow analysis is a technique designed to gather information about the values at each point of the program and how they change over time . this technique is often used by compilers to optimize the code . one of the most known examples of data-flow analysis is taint checking which consists of considering all variables which contain user supplied data which is considered '' tainted '' , i.e . insecure and preventing those variables from being used until they have been sanitized . this technique is often used to prevent sql injection attacks . taint checking can be done statically or dynamically . abstract interpretation . abstract interpretation allows the extraction of information about a possible execution of a program without actually executing the program . this information can be used by compilers to look for possible optimizations or for certifying a program against certain classes of bugs . type systems . type systems associate types to programs that fulfill certain requirements . their purpose is to select a subset of programs of a language that are considered correct according to a property . type checking – verify whether the program is accepted by the type system . type checking is used in programming to limit how a programming object is used and what can they do . this is done by the compiler or interpreter . type checking can also help prevent vulnerabilities by ensuring that a signed value is n't attributed to an unsigned variable . type checking can be done statically ( at compile time ) , dynamically ( at runtime ) or a combination of both . static type information ( either inferred , or explicitly provided by type annotations in the source code ) can also be used to do optimizations , such as replacing boxed type with unboxed arrays . effect systems . effect systems are formal systems designed to represent the effects executing a function or method can have . an effect codifies what is being done and with what it is being done usually referred to as effect kind and region , respectively . model checking . model checking refers to strict , formal , and automated ways to check if a model ( which in this context means a formal model of a piece of code , though in other contexts it can be a model of a piece of hardware ) complies with a given specification . due to the inherent finite state nature of code , and both the specification and the code being convertible into logical formulae , it is possible to check if the system violates the specification using efficient algorithmic methods . dynamic program analysis . dynamic analysis can use runtime knowledge of the program to increase the precision of the analysis , while also providing runtime protection , but it can only analyze a single execution of the problem and might degrade the program ’ s performance due to the runtime checks . testing . software should be tested to ensure its quality and that it performs as it is supposed to in a reliable manner , and that it won ’ t create conflicts with other software that may function alongside it . the tests are performed by executing the program with an input and evaluating its behavior and the produced output . even if no security requirements are specified , additional security testing should be performed to ensure that an attacker can ’ t tamper with the software and steal information , disrupt the software ’ s normal operations , or use it as a pivot to attack its users . monitoring . program monitoring records and logs different kinds of information about the program such as resource usage , events , and interactions , so that it can be reviewed to find or pinpoint causes of abnormal behavior . furthermore , it can be used to perform security audits . automated monitoring of programs is sometimes referred to as runtime verification . program slicing . for a given subset of a program ’ s behavior , program slicing consists of reducing the program to the minimum form that still produces the selected behavior . the reduced program is called a “ slice ” and is a faithful representation of the original program within the domain of the specified behavior subset . generally , finding a slice is an unsolvable problem , but by specifying the target behavior subset by the values of a set of variables , it is possible to obtain approximate slices using a data-flow algorithm . these slices are usually used by developers during debugging to locate the source of errors . see also . automated code review language-based security profiling ( computer programming ) program verification termination analysis . references . further reading . . external links .