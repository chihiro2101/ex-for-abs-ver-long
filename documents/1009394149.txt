Programming paradigm

overview . left just as software engineering ( as a process ) is defined by differing methodologies , so the programming languages ( as models of computation ) are defined by differing paradigms . some languages are designed to support one paradigm ( smalltalk supports object-oriented programming , haskell supports functional programming ) , while other programming languages support multiple paradigms ( such as object pascal , c++ , java , javascript , c , scala , visual basic , common lisp , scheme , perl , php , python , ruby , wolfram language , oz , and f ) . for example , programs written in c++ , object pascal or php can be purely procedural , purely object-oriented , or can contain elements of both or other paradigms . software designers and programmers decide how to use those paradigm elements . in object-oriented programming , programs are treated as a set of interacting objects . in functional programming , programs are treated as a sequence of stateless function evaluations . when programming computers or systems with many processors , in process-oriented programming , programs are treated as sets of concurrent processes that act on a logical shared data structures . many programming paradigms are as well known for the techniques they forbid as for those they enable . for instance , pure functional programming disallows use of side-effects , while structured programming disallows use of the goto statement . partly for this reason , new paradigms are often regarded as doctrinaire or overly rigid by those accustomed to earlier styles . yet , avoiding certain techniques can make it easier to understand program behavior , and to prove theorems about program correctness . programming paradigms can also be compared with programming models , which allows invoking an execution model by using only an api . programming models can also be classified into paradigms based on features of the execution model . for parallel computing , using a programming model instead of a language is common . the reason is that details of the parallel hardware leak into the abstractions used to program the hardware . this causes the programmer to have to map patterns in the algorithm onto patterns in the execution model ( which have been inserted due to leakage of hardware into the abstraction ) . as a consequence , no one parallel programming language maps well to all computation problems . thus , it is more convenient to use a base sequential language and insert api calls to parallel execution models via a programming model . such parallel programming models can be classified according to abstractions that reflect the hardware , such as shared memory , distributed memory with message passing , notions of place visible in the code , and so forth . these can be considered flavors of programming paradigm that apply to only parallel languages and programming models . criticism . some programming language researchers criticise the notion of paradigms as a classification of programming languages , e.g . harper , and krishnamurthi . . they argue that many programming languages can not be strictly classified into one paradigm , but rather include features from several paradigms . see comparison of multi-paradigm programming languages . history . different approaches to programming have developed over time , being identified as such either at the time or retrospectively . an early approach consciously identified as such is structured programming , advocated since the mid 1960s . the concept of a '' programming paradigm '' as such dates at least to 1978 , in the turing award lecture of robert w . floyd , entitled the paradigms of programming , which cites the notion of paradigm as used by thomas kuhn in his the structure of scientific revolutions ( 1962 ) . . machine code . the lowest-level programming paradigms are machine code , which directly represents the instructions ( the contents of program memory ) as a sequence of numbers , and assembly language where the machine instructions are represented by mnemonics and memory addresses can be given symbolic labels . these are sometimes called first- and second-generation languages . in the 1960s , assembly languages were developed to support library copy and quite sophisticated conditional macro generation and preprocessing abilities , call to ( subroutines ) , external variables and common sections ( globals ) , enabling significant code re-use and isolation from hardware specifics via the use of logical operators such as read/write/get/put . assembly was and still is , used for time-critical systems and often in embedded systems as it gives the most direct control of what the machine does . procedural languages . the next advance was the development of procedural languages . these third-generation languages ( the first described as high-level languages ) use vocabulary related to the problem being solved . for example , common business oriented language ( cobol ) uses terms like file , move and copy . formula translation ( fortran ) using mathematical language terminology , it was developed mainly for scientific and engineering problems . algorithmic language ( algol ) focused on being an appropriate language to define algorithms , while using mathematical language terminology , targeting scientific and engineering problems , just like fortran . programming language one ( pl/i ) a hybrid commercial-scientific general purpose language supporting pointers . beginners all purpose symbolic instruction code ( basic ) it was developed to enable more people to write programs . c a general-purpose programming language , initially developed by dennis ritchie between 1969 and 1973 at at & t bell labs . all these languages follow the procedural paradigm . that is , they describe , step by step , exactly the procedure that should , according to the particular programmer at least , be followed to solve a specific problem . the efficacy and efficiency of any such solution are both therefore entirely subjective and highly dependent on that programmer 's experience , inventiveness , and ability . object-oriented programming . following the widespread use of procedural languages , object-oriented programming ( oop ) languages were created , such as simula , smalltalk , c++ , c , eiffel , php , and java . in these languages , data and methods to manipulate it are kept as one unit called an object . with perfect encapsulation , one of the distinguishing features of oop , the only way that another object or user would be able to access the data is via the object 's methods . thus , an object 's inner workings may be changed without affecting any code that uses the object . there is still some controversy raised by alexander stepanov , richard stallman and other programmers , concerning the efficacy of the oop paradigm versus the procedural paradigm . the need for every object to have associative methods leads some skeptics to associate oop with software bloat ; an attempt to resolve this dilemma came through polymorphism . because object-oriented programming is considered a paradigm , not a language , it is possible to create even an object-oriented assembler language . high level assembly ( hla ) is an example of this that fully supports advanced data types and object-oriented assembly language programming despite its early origins . thus , differing programming paradigms can be seen rather like motivational memes of their advocates , rather than necessarily representing progress from one level to the next . precise comparisons of competing paradigms ' efficacy are frequently made more difficult because of new and differing terminology applied to similar entities and processes together with numerous implementation distinctions across languages . further paradigms . literate programming , as a form of imperative programming , structures programs as a human-centered web , as in a hypertext essay : documentation is integral to the program , and the program is structured following the logic of prose exposition , rather than compiler convenience . independent of the imperative branch , declarative programming paradigms were developed . in these languages , the computer is told what the problem is , not how to solve the problem the program is structured as a set of properties to find in the expected result , not as a procedure to follow . given a database or a set of rules , the computer tries to find a solution matching all the desired properties . an archetype of a declarative language is the fourth generation language sql , and the family of functional languages and logic programming . functional programming is a subset of declarative programming . programs written using this paradigm use functions , blocks of code intended to behave like function ( mathematics ) . functional languages discourage changes in the value of variables through assignment , making a great deal of use of recursion instead . the logic programming paradigm views computation as automated reasoning over a body of knowledge . facts about the problem domain are expressed as logic formulas , and programs are executed by applying inference rules over them until an answer to the problem is found , or the set of formulas is proved inconsistent . symbolic programming is a paradigm that describes programs able to manipulate formulas and program components as data . programs can thus effectively modify themselves , and appear to '' learn '' , making them suited for applications such as artificial intelligence , expert systems , natural-language processing and computer games . languages that support this paradigm include lisp and prolog . differentiable programming structures programs so that they can be differentiated throughout , usually via automatic differentiation . . support for multiple paradigms . most programming languages support more than one programming paradigm to allow programmers to use the most suitable programming style and associated language constructs for a given job .